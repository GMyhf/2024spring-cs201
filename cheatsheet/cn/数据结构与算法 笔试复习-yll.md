

# 数据结构与算法 笔试复习-yll

#### Sam2-1.6.

以下关于“算法”说法正确的有（ A, D ） 。

A： 算法一定是在有限步骤以内结束的

B： 算法一定是保证是正确的 C： 算法中不能有任何的随机成分

D： 算法的每一步都必须是明确的

## 一  数据结构



![3861718610230_.pic](/Users/yuanlai/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/20ef5b342c28f3861251200692178fd7/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/3861718610230_.pic.jpg)

数据结构的核心三要素包括：

1. **逻辑结构：** 逻辑结构是指数据对象中数据元素之间的关系。常见的逻辑结构包括线性结构（如数组、链表）、树形结构（如二叉树、多叉树）、图形结构等。逻辑结构决定了数据元素之间的组织方式和相互关系。
2. **存储结构：** 存储结构是指数据结构在计算机内存中的表示方式。常见的存储结构包括顺序存储结构和链式存储结构。顺序存储结构利用连续的存储单元存储数据元素，适用于线性结构；链式存储结构利用指针将数据元素分散存储在内存中，适用于树形结构和图形结构。
3. **运算及算法：** 运算及算法是指在数据结构上定义的一组基本操作，以及在这些操作上实现的算法。常见的数据结构操作包括查找、插入、删除等。算法则是对这些操作的具体实现方式，通过选择合适的算法可以提高数据结构的效率。

### 1 逻辑结构

**线性表**是一种逻辑结构，描述了元素按线性顺序排列的规则。常见的线性表存储方式有**数组**和**链表**，它们在不同场景下具有各自的优势和劣势。

数据的逻辑结构是指数据元素之间的逻辑关系和组织方式，它独立于数据的具体存储方式。数据的逻辑结构可以分
为以下几种主要类型:

1. **集合结构**

   定义:集合结构是最简单的逻辑结构，数据元素之间没有特定的顺序和关系，只是简单地归为一组。 

   特点:数据元素无序且互不关联。

2. **线性结构 **

   定义:有且仅有一个开始节点和一个终端节点，并且除了头尾，每个数据元素都有一个直接前驱和直接后继，是1对1的关系

   特点:数据元素之间存在一对一的顺序关系 常⻅的线性结构有:线性表、栈、队列、串(注意:这四种都是逻辑结构)

3. **非线性结构 **

   定义:一个节点可能有多个直接前驱和后继 

   特点:数据元素之间存在一对多的层次关系。 常⻅的非线性结构有:树、图

#### 0507-1.

下列叙述中正确的是（ D ）。 

A：散列是一种基于索引的逻辑结构 

B：基于顺序表**（线性表）**实现的逻辑结构属于线性结构 

C：数据结构设计影响算法效率，逻辑**（存储）**结构起到了决定作用 

D：一个逻辑结构可以有多种类型的存储结构，且不同类型的存储结构会直接影响到数据处理的效率

A：散列 hash哈希：一种数据处理方法，通过散列函数将任意大小的数据转换成固定长度的散列值

#### Sam2-1.1.

下列不属于线性结构的是（ A, D ）。 A：树 B：列表 C：栈 D：图

#### Sam2-1.2.

下面关于线性表的叙述中， 错误的是（ C ）。 A: 线性表采用顺序存储，必须占用一片连续的存储单元。

B: 线性表采用链接存储，不必占用一片连续的存储单元。 C: 线性表采用顺序存储，便于进行插入和删除操作。

D: 线性表采用链接存储，便于插入和删除操作。

### 2 存储结构-顺序存储-顺序表（存储密度=1）

**顺序存储结构**：把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现。

**随机访问**:每个结点的大小相同，可以计算得出任一结点的位置，直接进行访问。

数组是一种连续存储结构，它将线性表的元素按照一定的顺序依次存储在内存中的连续地址空间上。数组需要预先分配一定的内存空间，每个元素占用相同大小的内存空间，并可以通过索引来进行快速访问和操作元素。访问元素的时间复杂度为O(1)，因为可以直接计算元素的内存地址。然而，插入和删除元素的时间复杂度较高，平均为O(n)，因为需要移动其他元素来保持连续存储的特性。

<img src="/Users/yuanlai/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/20ef5b342c28f3861251200692178fd7/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/3881718610663_.pic.jpg" alt="3881718610663_.pic" style="zoom:50%;" />

**优点**:访问效率高，可以通过索引直接访问元素，时间复杂度为 (O(1))。内存空间紧凑，不存在指针存储开销。

**缺点**:插入和删除操作效率较低，尤其是在中间位置进行插入和删除时，可能需要移动大量元素，时间复杂度高。需要预先分配连续的内

存空间，可能导致内存浪费或分配失败。

**例子**: 

顺序表

基于数组实现的队列 (Queue) 和栈 (Stack)

#### 0402-2.1.

（ Y ）考虑一个长度为 n 的顺序表中各个位置插入新元素的概率是相同的，则顺序表的插入算法平均时间复杂度为 O(n) 。

#### 0402-3.1.

线性表的顺序存储与链式存储是两种常见存储形式；当表元素有序排序进行二分检索时，应采用 _ _ _ _ 存储形式。**（顺序）**

#### 0507-4.

若某线性表常用操作是在表尾插入或删除元素，则时间开销最小的存储方式是（ C ）。 A：单链表 B：仅有头指针的单循环链表 C：顺序表 D：仅有尾指针的单循环链表

### 3 存储结构-链式存储

**链接(链状)存储结构**:它不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段表示的

给结点分配的存储空间可以是连续的，也可以是不连续的。

**顺序访问**:访问中间结点需要从某结点开始，顺着链表进行，“顺藤 摸瓜”。

**链表**是一种存储结构，它是线性表的链式存储方式。链表通过节点的相互链接来实现元素的存储。每个节点包含元素本身以及指向下一个节点的指针。链表的插入和删除操作非常高效，时间复杂度为O(1)，因为只需要调整节点的指针。然而，访问元素的时间复杂度较高，平均为O(n)，因为必须从头节点开始遍历链表直到找到目标元素。 

<img src="/Users/yuanlai/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/20ef5b342c28f3861251200692178fd7/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/3891718610791_.pic.jpg" alt="3891718610791_.pic" style="zoom:50%;" />

**优点**:
 插入和删除操作效率高，时间复杂度为 (O(1))，只需修改指针指向。 不需要预先分配大块连续的内存空间。 

**缺点**:
 访问效率低，必须通过指针逐个遍历元素，时间复杂度为 (O(n))。 需要额外的存储空间存储指针，增加了存储开销。 

**例子**:
 单链表 (Singly Linked List) 双链表 (Doubly Linked List) 循环链表 (Circular Linked List) 

#### 0402-1.2.

链表不具有的特点是（ A ）。 A: 可随机访问任意元素 B: 插入和删除不需要移动元素 C: 不必事先估计存储空间 D: 所需空间与线性表长度成正比

#### 0507-3.

若某线性表采取链式存储，那么该线性表中结点的存储地址（ B ）。

A：一定不连续 

B：既可连续亦可不连续

C：一定连续 

D：与头结点存储地址保持连续

#### 0507-9.

（ N ）从链表中删除某个指定值的结点，其时间复杂度是 O(1)。

#### 1 单链表（存储密度<1）

在链式结构中，除了要存储数据元素的信息外，还要存储它的后继元素的存储地址。

​	因此，为了表示**每个数据元素$$a_{i}$$与其直接后继元素$$a_{i+1}$$之间的逻辑关系，对数据$$a_{i}$$来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素$$a_{i}$$的存储映像，称为结点（$$Node$$​）。**

​	我们把链表中第一个结点的存储位置叫做头指针。有时为了方便对对链表进行操作，会在单链表的第一个结点前附设一个节点，称为头结点，此时头指针指向的结点就是头结点。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210207165354972.png#pic_center)

​	空链表，头结点的直接后继为空。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210207165435359.png#pic_center)



##### 0507-7.

对于单链表，表头节点为 head，判定空表的条件是（ D ）。 A: head.next == None B: head != None C: head.next == head D: head == None

##### 0507-12.

考察以下基于单链表的操作，相较于顺序表实现，带来更高时间复杂度的操作是（ D ）。

A：合并两个有序线性表，并保持合成后的线性表依然有序 

B：交换第一个元素与第二个元素的值 

C：查找某一元素值是否在线性表中出现 

D：输出第 i 个（0<=i<n，n 为元素个数）元素

##### 0507-2.

（7 分）链表操作：读入一个从小到大排好序的整数序列到链表，然后在链表中删除重复的元素，使得重复的元素只保留 1 个，然后将整个链表内容输出。

输入样例：

```
1 2 2 2 3 3 4 4 6
```

输出样例:

```
1 2 3 4 6
```

请对程序填空:

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

a = list(map(int, input().split()))
head = Node(a[0])
p = head
for x in a[1:]:
    p.next = Node(x)    # 【2 分】
    p = p.next

p = head
while p:
    while p.next and p.data == p.next.data: # 【2 分】
        p.next = p.next.next    #【1 分】
    p = p.next

p = head
while p:
    print(p.data, end=" ")
    p = p.next  # 【2 分】
```

#### 2 双链表

**双向链表$$(Double$$ $$Linked$$ $$List)$$是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。**所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。

#### 3 循环链表

**将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。**

​	然而这样会导致访问最后一个结点时需要$$O(n)$$的时间，所以我们可以写出**仅设尾指针的循环链表**。

### 3 索引存储

**索引存储结构**:在主表存储结点信息之外，还有附加的索引表 (也叫目录表) 来标识结点的地址。 

key 由结点的属性生成 

索引表可以有多个 

在索引存储结构中，为了加快查找速度，在数据元素之外建立索引表，通过索引表来快速定位数据元 

素。索引存储结构常用于大规模数据的查找操作。 

**优点**: 查找效率高，可以快速定位数据元素。 

**缺点**: 需要额外的存储空间存储索引表。插入和删除操作较复杂，需要维护索引表。 

**例子**: 

数据库索引 (B树、B+树) 

倒排表 

### 4 散列存储

**散列存储结构（hash，哈希）**就是根据结点的关键字直接计算出该结点的存储地址。

<img src="/Users/yuanlai/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/20ef5b342c28f3861251200692178fd7/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/3871718610524_.pic.jpg" alt="3871718610524_.pic" style="zoom: 50%;" />

在散列存储结构中，通过散列函数将数据元素的关键字映射到存储地址，实现快速查找和存储。 

**优点**: 查找、插入和删除操作效率高，时间复杂度为 (O(1))(平均情况下)。 

**缺点**: 需要设计良好的散列函数以减少冲突。处理冲突的方法(如开放地址法、链地址法)可能影响性能。

**例子**:
 哈希表 (Hash Table) 

#### 0402-1.11.

有一个散列表如下图所示，其散列函数为 h(key)=key mod 13，该散列表使用再散列函数 H2(Key)=Key MOD 3 解决碰撞，问从表中检索出关键码 38 需进行几次比较（ B ）。

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 26   | 38   |      |      | 17   |      |      | 33   |      | 48   |      |      | 25   |

A： 1 B：2 C: 3 D： 4

#### 0402-2.4.

（ N ）由于碰撞的发生，基于散列表的检索仍然需要进行关键码对比，并且关键码的比较次数**（查找效率）**仅取决于选择的散列函数与处理碰撞的方法两个因素 散列表实际元素及个数。

#### 0507-8.

（ Y ）使用线性探测法处理散列表碰撞问题，若表中仍有空槽（空单元），插入操作一定成功。

#### 0507-9.

给定一个长度为 7 的空散列表，采用双散列法解决冲突，两个散列函数分别为：h1(key) = key % 7，h2(key) = key%5 + 1 请向散列表依次插入关键字为 30, 58, 65 的集合元素，插入完成后 65 在散列表中存储地址为 _ _ _ _ _ 。**3**

#### Sam2-1.7.

在各种查找方法中，平均比对次数与元素个数 n 无关的查找方法是（ A ）。

A: 散列查找 B: 顺序查找 C: 二分查找 D: 没有这样的查找方法使得平均查找长度和 n 无关

#### Sam2-1.8.

影响散列查找时间效率的主要因素（ A,C,D ）。

A: 散列函数的选择 B: 散列表的长度 C: 散列表实际元素及个数 D: 散列表的冲突解决方法

\#解释：

- A：散列函数的选择直接影响着关键码映射到散列表位置的效果，合适的散列函数可以降低冲突的发生，提高查找效率。
- C：散列表实际元素的个数决定了散列查找中需要比较的元素数量，实际元素越多，查找时间效率越低。
- D：散列表的冲突解决方法影响着冲突处理的效率，不同的冲突解决方法可能导致不同的查找效率。例如，开放定址法、链表法等。

B 选项中，散列表的长度通常是由散列函数的选择和实际元素的数量来确定的，它们对散列查找时间效率的影响更为直接

#### Sam2-1.9.

给定关键码序列 26, 25, 20, 33, 21, 24, 45, 204, 42, 38, 29, 31，用散列法进行存储(本题采用+2 跳跃开放定址方法 open addressing 解决冲突)，规定负载因子 α<0.6, 以下最合理的除余法的散列函数为（ C ）。

A: H(key)=key % 17 B: H(key)=key % 18 C: H(key)=key % 19 D: H(key)=key % 20

\#散列表的负载因子是指散列表中已存储元素的数量与散列表总容量之间的比率。通常用公式表示为：

**载荷因子=元素个数/散列表大小**

载荷因子的大小直接影响着散列表的性能。当载荷因子较小时，散列表中空闲位置较多，插入新元素时冲突的可能性较低，查找、插入和删除操作的效率较高。但是，随着插入元素的增多，载荷因子会逐渐增大，导致冲突的概率增加，从而降低了散列表的性能。

一般来说，当载荷因子超过某个阈值时，就需要对散列表进行扩容操作，以保持其性能。常见的载荷因子阈值通常设定为 0.7 或 0.8，当超过这个阈值时，就需要将散列表的容量增加一倍，并重新计算所有元素的哈希值，将其重新分配到新的散列表中，以减少冲突的发生。

为了确保负载因子小于0.6，我们需要选择一个合适的散列函数，以尽可能均匀地将关键码分布在散列表中。

计算关键码序列中的关键码数量。根据题目给出的关键码序列，共有12个关键码。

接下来，我们计算散列表的大小，即最合适的除余数。根据规定的负载因子 α<0.6，可以使用以下公式计算散列表的大小：

**表大小=12/0.6=20**

给定的选项中，选出最接近关键码数量的素数19。

## 二 时间复杂度

#### 0402-1.1.

下列不影响算法时间复杂性的因素有（ C ）。 A：问题的规模 B：输入值 C：计算结果 D：算法的策略

#### 0507-10.

阅读算法 ABC，回答问题。

```python
def ABC(n):
  k, m = 2, int(n**0.5)
  while (k <= m) and (n %k != 0):
    k += 1
  return k > m
```



1）算法的功能是：_ _ _ _ 。**素数判断**

2）算法的时间复杂度是O( _ _ _ _ )。**n**0.5**

#### 0507-1.

（4 分）字符串匹配算法从长度为 n 的文本串 S 中查找长度为 m 的模式串 P 的首次出现。

a）字符串匹配的朴素算法使用暴力搜索，大致过程如下：对于 P 在 S 中可能出现的 n-m+1 个位置，比对此位置时 P 和 S 中对应子串是否相等。其时间复杂度 O((n-m+1)m)。请举例说明算法时间复杂度一种最坏情况（注：例子中请只出现 a 和 b 两种字符）。（1分）

b）已知字符串 S 为“abaabaabaabcc”，模式串 t 为“abaabc”。采用朴素算法进行查找，请写出字符比对的总次数和查找结果。（2 分）

c）朴素算法存在很大的改进空间，说明在上述(b)步骤中，第一次出现不匹配（s[i+j] != t[j]）时（i=0, j=5），为了避免冗余比对，则下次比对时，i 和 j 的值可以分别调整为多少？（1分）

字符串匹配的朴素算法：

```python
def issubstring(s, t):
    for i in range(len(s)):
        for j in range(len(t)):
            if s[i + j] != t[j]:
                break
        else:
            return True
    return False
```



答：

问题 a) 如 P=“a^m-1^b”，S=“a^n-1^b”，执 行 朴 素 算 法 刚 好 需 要(n-m+1)m 次比对。

问题 b) 需要 24 次比对得到 True 结果

问题 c) i=3, j=2

#### Sam-1.1.

下列不影响算法时间复杂性的因素有（B,C ）。 A：问题的规模 B：输入值 C：计算结果 D：算法的策略

#### Sam-2.1.

以下时间复杂度从小到大的顺序是（ ）：

A、 (lg⁡ (n))! B、 2𝑙𝑔⁡(𝑛) C、 2𝑙𝑔(𝑙𝑔𝑛)D、 lg⁡ (n!)

\#让我们逐个分析这些时间复杂度，并将它们从小到大排列：

A、 ( (lg(n))! )：阶乘的增长速度非常快，即使在 ( n ) 值较小的情况下，( (lg(n))! ) 的增长速度也会非常快，远远超过其他选项。

B、 ( \sqrt{2^{lg(n)}} )：这是一个指数级别的平方根。尽管平方根增长速度较慢，但在这种情况下，指数内部是对数级别，因此整体的增长速度相对较快。。

C、 ( 2^{lg(lgn)} )：这个表达式等价于 ( lgn )，虽然增长速度较快，但比 ( n ) 的增长速度慢，因此在这个列表中排在第二位。

D、 ( lg(n!) )：( lg(n!) ) 的增长速度介于 ( lgn ) 和 ( n ) 之间，它比 ( lgn ) 快，但比 ( n ) 慢。

所以，从小到大排列的顺序是：C、D、B、A。

### 1 排序问题

![3931718648205_.pic](/Users/yuanlai/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/20ef5b342c28f3861251200692178fd7/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/3931718648205_.pic.jpg)

#### 0402-1.7.

假设线性表中每个元素有两个数据项 key1 和 key2，现对线性表按以下规则进行排序：先根据数据项 key1 的值进行非递减排序；在 key1 值相同的情况下，再根据数据项 key2 的值进行非递减排序。 满足这种要求的排序方法是（ D ）。 

A: 先按key1 值进行冒泡排序，再按 key2 值进行直接选择排序 

B: 先按key2 值进行冒泡排序，再按 key1 值进行直接选择排序 

C: 先按key1 值进行直接选择排序，再按 key2 值进行冒泡排序 

D: 先按key2 值进行直接选择排序，再按 key1 值进行冒泡排序

#### 0402-1.8.

有n^2 个整数，找到其中最小整数需要比较次数至少为（ C ）次。 

A:n B: log2n C:n^2-1 D:n-1

#### 0507-8.

以下典型排序算法中，具有稳定排序特性的是（ A ）。 

A:冒泡排序（Bubble Sort） B: 直接选择排序（Selection Sort）C:快速排序（Quick Sort） D:希尔排序（Shell Sort）

#### 0507-10.

以下典型排序算法中，内存开销最大的是（ C ） 。 A：冒泡排序 B：快速排序 C：归并排序 D：堆排序

#### 0507-11.

排序算法依赖于对元素序列的多趟比较/移动操作（即执行多轮循环），第一趟结束后，任一元素 都无法确定其最终排序位置的算法是（ D ）。

A：选择排序 B：快速排序 C: 冒泡排序 D：插入排序

#### 0507-4.

如果输入序列是已经正序，在(改进)冒泡排序、直接插入排序和直接选择排序算算法中， _ _ _ _ 算法最慢结束。**直接选择排序**



#### 0402-2.3.

（ Y ）直接插入排序、冒泡排序、希尔排序都是在数据正序的情况下比数据在逆序的情况下要快。

#### 0402-3.2.

如果只想得到1000 个元素的序列中最小的前 5个元素，在冒泡排序、快速排序、堆排序和归并排序中，哪种算法最快？**（堆排序）**

待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中Ri领先于Rj（即i＜j）.若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。比如int数组[1,1,1,6,4]中a[0],a[1],a[2]的值相等，在排序时不改变其序列，则称所用的方法是稳定的。

#### Sam2-1.10.

对于排序算法特性的叙述正确的是（ A,B,C ）。

A: 冒泡排序不需要访问那些已排好序的记录 B: 谢尔排序中，当对确定规模的这些小序列进行插入排序时，要访问序列中的所有记录 C: 快速排序过程中，递归树上根据深度划分的每个层次都要访问序列中的所有记录 D: 选择排序需要访问那些已排好序的记录 E: 归并排序过程中，递归树上每个层次的归并操作不需要访问序列中的所有记录 F: 基数排序过程中，按照每个排序码进行的桶式排序不需要访问序列中的所有记录

\#让我们逐个分析：

A: 冒泡排序需要访问已排好序的记录，因为它在每一轮排序时都要比较相邻的元素，并根据需要交换它们的位置，以将最大（或最小）的元素逐渐“冒泡”到正确的位置。因此，选项A不正确。

B: 谢尔排序在确定规模的小序列上执行插入排序，这意味着对于每个小序列，它会访问该小序列中的所有记录，以便进行插入排序。因此，选项B正确。

C: 快速排序是基于分治策略的排序算法，每次选择一个基准值，将序列分为两部分，并递归地对每个子序列进行排序。在递归树的每个层次上，都要访问序列中的所有记录，以进行基准值的选择和分区。因此，选项C正确。

D: 选择排序在每一轮选择最小（或最大）的元素时，需要访问未排序部分和已排序部分中的记录，以确定最小（或最大）的元素的位置，并进行交换。因此，选项D不正确。

#### Sam2-1.11

下面的排序算法哪个是不稳定的( )。

A、 插入排序

B、 归并排序

C、 冒泡排序

D、 快速排序

#### Sam2-1.12

**在第一趟排序之后，不能确保将数据表中某一个元素放在其最终位置上的排序算法**

**( )。**

A.选择排序

B.冒泡排序

C.快速排序

D.归并排序

#### Sam2-1.13

下列关于排序算法时间复杂度的描述错误的是（ B ）。

A: 冒泡排序的最差时间复杂度是O(n^2) B: 快速排序的最差时间复杂度是O(nlog(n)) C: 归并排序的最差时间复杂度是O(nlog(n)) D: 谢尔排序的时间复杂度在O(n)和O(n2)之间

#### Sam2-1.14

对关键字序列（30， 26， 18， 16， 5， 66），进行 2 遍（ C ）排序后得到序列（5，16， 18， 26， 30， 66）。

A: 插入 B: 冒泡 C: 选择 D: 归并

#### 1.冒泡排序（稳定）

具有稳定排序特性

每次比较相邻两个，把相邻两个大小关系调整好，一轮一轮排序

#### 2.插入排序（稳定）

插入排序是一种基本的排序算法，其思想在于通过先前的已排好序的数组得到目标插入元素的插入位置，从而达到不断排序的目的。

​	时间复杂度：$$O(n^2)$$；空间复杂度：$$O(1)$$。

​	插入排序是一种稳定的原地排序算法。

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >= 0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key

```



#### 3.希尔排序（不稳定）

希尔排序可以看作是插入排序的变种，也就相当于可以交换远项。

​	时间复杂度：（最差）$$O(n^2)$$；空间复杂度：$$O(1)$$​。

​	希尔排序的时间复杂度取决于算法的对象，是不稳定的。

```python
def shell_sort(arr, n):
    gap = n // 2
    while gap > 0:
        j = gap
        while j < n:
            i = j - gap
            while i >= 0:
                if arr[i+gap] > arr[i]:
                    break
                else:
                    arr[i+gap], arr[i] = arr[i], arr[i+gap]
                i -= gap
            j += 1
        gap //= 2

```



#### 0402-2.2.

（ N ）希尔排序算法的每一趟都要调用一次或多次直接插入排序算法，所以其效率比直接插入排序算法差。

#### 0507-13.

已知一个整型数组序列，序列元素值依次为 ( 19，20，50，61，73，85，11，39 )，采用某种排序算法，在多趟比较/移动操作（即执行多轮循环）后，依次得到以下中间结果（每一行对应一趟）如下： （1）19 20 11 39 73 85 50 61 （2）11 20 19 39 50 61 73 85 （3）11 19 20 39 50 61 73 85 请问，上述过程使用的排序算法是（ C ）。

A：冒泡排序 B：插入排序 C：希尔排序 D：归并排序

#### 4.归并排序（稳定）mergesort

#### 0402-3.8.

有n 个数据对象的二路归并排序中，每趟归并的时间复杂度为 _ _ _ _ 。**（O(n)）**

#### 0402.3.9.

对一组记录进行降序排序，其关键码为（46，70，56，38，40，80，60，22），采用初始步长为 4 的希尔（shell）排序，第一趟扫描的结果是（ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ）；而采用归并排序第一轮归并结果是（ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ）。**（46,80,60,38,40,70,56,22），（70,46,56,38,80,40,60,22）**



归并排序作为一种排序算法，其原理是将数组划分为更小的子数组，对每个子数组进行排序，然后将排序后的子数组合并在一起，形成最终的排序数组。（和快速排序同样的分治思想）

​	时间复杂度：$$O(nlogn)$$；空间复杂度：$$O(n)$$​。

​	归并排序是一种天然的可并行化算法，而且稳定，因此特别适合用来处理大数据集，但它需要额外空间。

```python
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left = arr[:mid]
        right = arr[mid:]
        merge_sort(left)
        merge_sort(right)
        i, j, k = 0, 0, 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            arr[k] = left[i]
            i += 1
            k += 1
        while j > len(right):
            arr[k] = right[j]
            j += 1
            k += 1

```



#### 5.选择排序$$(Selection$$ $$Sort)$$ 不稳定

​	选择排序是一种简单且高效的排序算法，其工作原理是从列表的未排序部分反复选择最小(或最大)元素，并将其移动到列表的已排序部分。

​	时间复杂度：$$O(n^2)$$；空间复杂度：$$O(1)$$。

​	选择排序同样是一种原地排序算法，无需额外空间，但它在小的数据集下相对高效，在极端情况下会具有较大的时间复杂度，是不稳定的。

```python
def selection_sort(arr):
    for p in range(len(arr)-1, 0, -1):
        position = 0
        for location in range(1, p+1):
            if arr[location] > arr[position]:
                position = location
        if p != position:
            arr[p], arr[position] = arr[position], arr[p]

```

#### 6.快速排序$$(Quick$$ $$Sort)$$不稳定

​	快速排序是一种基于分治算法的排序算法，它选择一个元素作为基准，并通过将基准放置在已排序数组中的正确位置来围绕所选择的基准对给定数组进行分区。

​	时间复杂度：最好时为$$O(nlogn)$$，最差时为$$O(n^2)$$；空间复杂度：考虑递归堆栈，为$$O(n)$$，不考虑则为$$O(1)$$。

​	快速排序相对更适用于大数据集，在某些极端情况下会显现出较差的时间复杂度，是不稳定的。

$$P.S:$$ 似乎二叉搜索树的建树再加上中序遍历，就可以获得同样的结果。

```python
def quick_sort(arr, left, right):
    if left < right:
        position = partition(arr, left, right)
        quick_sort(arr, left, position-1)
        quick_sort(arr, position+1, right)
def partition(arr, left, right):
    i = left
    j = right-1
    pivot = arr[right]
    while i <= j:
        while i <= right and arr[i] < pivot:
            i += 1
        while j >= left and arr[j] >= pivot:
            j -= 1
        if i < j:
            arr[i], arr[j] = arr[j], arr[i]
    if arr[i] > pivot:
        arr[i], arr[right] = arr[right], arr[i]
    return i

```

![img](https://pics1.baidu.com/feed/8694a4c27d1ed21b4b36a48b380be7cd50da3f4b.jpeg@f_auto?token=9ffc13ea5f03ec6107010043941c904a)

#### 0507-3.

对于初始排序码序列（51, 41, 31, 21, 61, 71, 81, 11, 91），用双指针原地交换实现，第 1 趟快速排序（以第一个数字为中值）的结果是： _ _ _ _ 。**11 41 31 21 51 71 81 61 91**

#### 7.堆排序（不稳定）

堆排序是一种基于完全二叉树（堆）的排序算法。它通过将待排序的元素构建成一个堆，然后利用堆的性质来实现排序。在堆中，每个结点的值都必须大于等于其子结点的值。

​	时间复杂度：$$O(nlogn)$$；空间复杂度：$$O(1)$$​​。

​	堆排序适合处理大型数据集，采取原地排序，但不稳定，因为可能会交换相同元素。

```python
def heapify(arr, n, i):
    largest = i
    l = 2*i + 1
    r = 2*i + 2
    if l < n and arr[l] > arr[largest]:
        largest = l
    if r < n and arr[r] > arr[largest]:
        largest = r
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapsort(arr):
    n = len(arr)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

```

解答：

对完全二叉树建堆，给出初始建堆算法python

```python
def heapify(arr):
    n = len(arr)
    # 从最后一个非叶子节点开始，依次向下调整每个节点
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, i, n)

def heapify_down(arr, i, n):
    smallest = i  # 假设当前节点最小
    left_child = 2 * i + 1
    right_child = 2 * i + 2

    # 如果左子节点存在且小于当前节点，则更新最小值索引
    if left_child < n and arr[left_child] < arr[smallest]:
        smallest = left_child

    # 如果右子节点存在且小于当前节点，则更新最小值索引
    if right_child < n and arr[right_child] < arr[smallest]:
        smallest = right_child

    # 如果最小值索引不等于当前节点索引，则交换当前节点和最小值节点的值，并继续向下调整
    if smallest != i:
        arr[i], arr[smallest] = arr[smallest], arr[i]
        heapify_down(arr, smallest, n)

# 测试
arr = [31, 8, 53, 10, 20, 7, 15, 3, 20, 1]
heapify(arr)
print(arr)
# [1, 3, 7, 10, 8, 53, 15, 31, 20, 20]
```



1）根据初始建堆算法，我们从最后一个非叶子节点开始，依次向上调整，保证每个节点都满足小根堆的性质。

```
          1
       /      \
     3         7
   /  \       /   \
  10   8    53    15
 / \	 
31 20 
```



2）删除最小元素后，将最后一个元素放到根节点，并进行堆调整：

```
         (20)
       /      \
     3         7
   /  \       /   \
  10   8    53    15
 / \	 
31 20 
```



```
          3
       /      \
    (20)         7
   /  \       /   \
  10   8    53    15
 / \	 /
31 20 20
```



```
          3
       /      \
     8         7
   /  \       /   \
  10  (20)    53    15
 / \	 
31 20 
```



3）插入元素 2 后，将元素 2 放到堆的最后，然后进行堆调整：

```
          1
       /      \
     3         7
   /  \       /   \
  10   8    53    15
 / \	 /\
31 20 20 (2)
```



```
          1
       /      \
     3         7
   /  \       /   \
  10  (2)   53    15
 / \	 /\
31 20 20 8
```



```
          1
       /      \
    (2)         7
   /  \       /   \
  10   3    53    15
 / \	 /\
31 20 20 8
```

## 

#### 0507-9.

以下关键字列表中，可以有效构成一个大根堆（即最大值二叉堆，最大值在堆顶）的序列是（ D ）。 A: 5 8 1 3 9 6 2 7 B: 9 8 1 7 5 6 2 33 C: 9 8 6 3 5 1 2 7 D: 9 8 6 7 5 1 2 3

#### 0507-2.

（ N ）构建一个含 N 个结点的（二叉）最小值堆，时间效率最优情况下的时间复杂度大 O 表示为 O (N Log N) **O(N)**。

#### Sam2-1.5.

下列关于堆的说法正确的有（ B, C, D ）。 A：最小堆中，最下面一层最靠右的结点一定是权值最大的结点。

B：堆一定是完全二叉树。 C：最小堆中，某个结点左子树中最大的结点可能比右子树中最小的结点小。

D：使用“下沉” 法建堆要比将元素一个一个插入堆来建堆效率高。

#### 0402-4.3.

下图是一棵完全二叉树： 1） 请根据初始建堆算法对该完全二叉树建堆，请画出构建的小根堆（2 分）； 2）基于（1）中得到的堆，删除其中的最小元素，请用图给出堆的调整过程（2 分）； 3）基于（1）中得到的堆，向其中插入元素 2，请给出堆的调整过程（2 分）。 注：每移动一个元素视为一个执行步骤，画出所有执行步骤

```
          31
       /      \
     8         53
   /  \       /   \
  10   20    7    15
 / \	 /
3  20 1
```

解答：

对完全二叉树建堆，给出初始建堆算法python

```python
def heapify(arr):
    n = len(arr)
    # 从最后一个非叶子节点开始，依次向下调整每个节点
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, i, n)

def heapify_down(arr, i, n):
    smallest = i  # 假设当前节点最小
    left_child = 2 * i + 1
    right_child = 2 * i + 2

    # 如果左子节点存在且小于当前节点，则更新最小值索引
    if left_child < n and arr[left_child] < arr[smallest]:
        smallest = left_child

    # 如果右子节点存在且小于当前节点，则更新最小值索引
    if right_child < n and arr[right_child] < arr[smallest]:
        smallest = right_child

    # 如果最小值索引不等于当前节点索引，则交换当前节点和最小值节点的值，并继续向下调整
    if smallest != i:
        arr[i], arr[smallest] = arr[smallest], arr[i]
        heapify_down(arr, smallest, n)

# 测试
arr = [31, 8, 53, 10, 20, 7, 15, 3, 20, 1]
heapify(arr)
print(arr)
# [1, 3, 7, 10, 8, 53, 15, 31, 20, 20]
```



1）根据初始建堆算法，我们从最后一个非叶子节点开始，依次向上调整，保证每个节点都满足小根堆的性质。

```
          1
       /      \
     3         7
   /  \       /   \
  10   8    53    15
 / \	 
31 20 
```



2）删除最小元素后，将最后一个元素放到根节点，并进行堆调整：

```
         (20)
       /      \
     3         7
   /  \       /   \
  10   8    53    15
 / \	 
31 20 
```



```
          3
       /      \
    (20)         7
   /  \       /   \
  10   8    53    15
 / \	 /
31 20 20
```



```
          3
       /      \
     8         7
   /  \       /   \
  10  (20)    53    15
 / \	 
31 20 
```



3）插入元素 2 后，将元素 2 放到堆的最后，然后进行堆调整：

```
          1
       /      \
     3         7
   /  \       /   \
  10   8    53    15
 / \	 /\
31 20 20 (2)
```



```
          1
       /      \
     3         7
   /  \       /   \
  10  (2)   53    15
 / \	 /\
31 20 20 8
```



```
          1
       /      \
    (2)         7
   /  \       /   \
  10   3    53    15
 / \	 /\
31 20 20 8
```

#### 0507-4.

（6 分）堆排序：输入若干个整数，下面的程序使用堆排序算法对这些整数从小到大排序，请填空。 程序中建立的堆是大顶堆（最大元素在堆顶）

输入样例：

```
1 3 43 8 7
```



输出样例:

```
1 3 7 8 43
```



请进行程序填空：

```python
def heap_sort(arr):
    heap_size = len(arr)

    def goDown(i):
        if i * 2 + 1 >= heap_size:  # a[i]没有儿子
            return
        L, R = i * 2 + 1, i * 2 + 2

        if R >= heap_size or arr[L] > arr[R]:   # 【1 分】
            s = L
        else:
            s = R

        if arr[s] > arr[i]:
            arr[s], arr[i] = arr[i], arr[s] # 【2 分】
            goDown(s)

    def heapify():	# 将列表 a 变成一个堆
        for k in range(len(arr) // 2 - 1, -1, -1): # 【1 分】
            goDown(k)

    heapify()
    for i in range(len(arr) - 1, -1, -1):
        arr[0], arr[i] = arr[i], arr[0] # 【1 分】
        heap_size -= 1
        goDown(0)   # 【1 分】


a = list(map(int, input().split()))
heap_sort(a)
for x in a:
    print(x, end=" ")
```



卷面写法怪异，正常写法应该是

```python
def heapify(arr, n, i):
    largest = i  # 将当前节点标记为最大值
    left = 2 * i + 1  # 左子节点的索引
    right = 2 * i + 2  # 右子节点的索引

    # 如果左子节点存在且大于根节点，则更新最大值索引
    if left < n and arr[i] < arr[left]:
        largest = left

    # 如果右子节点存在且大于根节点或左子节点，则更新最大值索引
    if right < n and arr[largest] < arr[right]:
        largest = right

    # 如果最大值索引发生了变化，则交换根节点和最大值，并递归地堆化受影响的子树
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)


def buildMaxHeap(arr):
    n = len(arr)

    # 从最后一个非叶子节点开始进行堆化
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)


def heapSort(arr):
    n = len(arr)

    buildMaxHeap(arr)  # 构建大顶堆

    # 逐步取出堆顶元素（最大值），并进行堆化调整
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # 交换堆顶元素和当前最后一个元素
        heapify(arr, i, 0)  # 对剩余的元素进行堆化

    return arr

a = list(map(int, input().split()))
heapSort(a)
for x in a:
    print(x, end=" ")
```

#### 





## 三 队列与栈

### 1 栈实现

堆栈又名栈（stack），它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素

上进上出

[<img src="https://img1.baidu.com/it/u=3305703712,486266381&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1718730000&t=d25131c53fbce0304fe7293d4476f236" alt="img" style="zoom:50%;" />](https://www.baidu.com/link?url=Z6nfuPn0-fDT0XjbTUfgyDgajMAMKRyo5ZJM5fvA0kCPm3jZnjEdpGMNI-Jxyt2Q8SAL4Hq1sc3pCkacLh_FLbtqW0Akmxg96zVg1RAmfO58mn9Es3wkHandbNKutggAcC-hkc_-6ghk_PcBfjU_qVTIPLrwgOlCokvSo002GRQXZIzVsosMlyOly5LunKWB4QhvPrMqqN57cCM_IGED9MJZnNfOYlh4sEg0iA7l4_BC4WI0HntixigQEM0Ih5TNP73PbsMF4CgjslLAXPLfNT_I87ompndC8ltGFQpeUNq59hrmVluIjxg3fjnwSjubtVGTPT8scLb3WtdeOMb4qiwjh02GffAzqv-qpzIqjpmdIQlL8bi4-4grxgnJwDp-QdmrLbH1DYPYQ6MxtqCkcezeShOhmFYvwJ3QqTj0o7z4scvP8qKfPdqbUmsB_C5WytExx9nxPqWQZBXY65LTYUWjqDX0NX5gvoMhMmox2zweb3cQ7y9nMzvMoBnzVa-FDTsDuBmY3zc_4zTFr81CC1ucVYaQwvcOiOFwzLVaHTXq2GCgwn5Vw2L_JgcCrtzq8UADh1NnH2A6ubOZR9LuB45trMpHfCepqRSJjixamrfBTGTSLzZ2GuvhmfvUl-z8b5lI7App2YTBBYbPtDPoPa&wd=&eqid=b0096aef0008714c0000000266705750)

#### 0402-1.3.

设有三个元素X，Y，Z 顺序进栈（进的过程中允许出栈），下列得不到的出栈排列是（ C ）。 A：XYZ B：YZX C：ZXY D：ZYX

#### 0402-1.14.

允许表达式内多种括号混合嵌套，检查表达式中括号是否正确配对的算法，通常选用（ A ）。 A： 栈 B：线性表 C： 队列 D： 二叉排序树

#### 0507-6.

今有一空栈 S，基于待进栈的数据元素序列 a, b, c, d, e, f 依次进行进栈、进栈、出栈、进 栈、进栈、出栈的操作，上述操作完成以后，栈 S 的栈顶元素为（ B ）。

A：f B：c C：a D：d

#### 1.经典栈实现

前缀表达式、中缀表达式、后缀表达式

- 前缀表达式（又称波兰式），操作符位于两个运算数之前。例如，3 + 2 的前缀表达形式就是 + 3 2。前缀表达式不需要使用括号来标识操作符的优先级，适用于计算机处理。
- 中缀表达式，操作符位于运算数中间，是我们日常通用的算术和逻辑公式表示方法。例如，3 + 2。中缀表达式往往需要使用括号将操作符和对应的操作数括起来，用于指示运算的次序。
- 后缀表达式（又称逆波兰式），操作符位于两个运算数之后。例如，3 + 2 的后缀表达形式就是 3 2 +。后缀表达式的计算按操作符从左到右出现的顺序依次执行，更加符合人类的阅读习惯，因此实际计算机程序中，基本都是用后缀表达式来存储公式的。

#### 0507-5.

给定后缀表达式（逆波兰式）ab+-c*d-对应的中缀表达式是（ B ）。 A： a - b - c * d B：- ( a + b ) * c -d C： a + b * c - d D： ( a + b ) * ( - c - d )

#### 0507-6.

使用栈计算后缀表达式 (操作数均为一位数) “1 2 3 + 4 * 5 + 3 + −” ，当扫描到第二个+号但还未对该+号进行运算时，栈的内容 (以栈底到栈顶从左往右的顺序书写) 为 _ _ _ _ 。**1,20,5**

#### Sam2-1.3.

设栈 S 和队列 Q 的初始状态为空，元素 a， b， c， d， e 依次通过栈 S，一个元素出栈后即进队列 Q，若 5 个元素出队的序列是 c， e， d， b， a 则栈 S 的容量至少应该是（ C ）。 A：2 B：3 C：4 D：5

### 2 双端队列

#### 0402-3.3.

设环形队列的容量为 20（单元编号从 0 到19），现经过一系列的入队和出队运算后，队头变量（第一个元素的位置）front=18，队尾变量（待插入元素的位置）rear=11，在这种情况下，环形队列中有 _ _ _ _ 个元素。**（13）**

### 3 二分查找



#### 2022-1.2.

![3921718647633_.pic](/Users/yuanlai/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/20ef5b342c28f3861251200692178fd7/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/3921718647633_.pic.jpg)

**D**

## 三 树

### 1 树的基本性质

树的度数：树中度数最大的点的度数

基本概念:树的高度、结点度数

**树的高度**通常指的是从根节点到最远叶子节点的最长路径上的节点总数

父节点到子结点之间的关系，可以看成有向边;

**结点度数**等于顶点出度

#### 0402-1.12.

在一棵度为 3 的树中，度为 3 的节点个数为 2，度为 2 的节点个数为 1，则度为 0 的节点个数为（ C ）。

 A： 4 B：5 C： 6 D： 7

### 2 二叉树



#### 0403-1.5.

若定义二叉树中根结点的层数为零，树的高度等于其结点的最大层数加一。则当某二叉树的前序序列和后序序列正好相反，则该二叉树一定是（ B ）的二叉树。 A： 空或只有一个结点 B：高度等于其节点数 C： 任一结点无左孩子 D： 任一结点无右孩子

#### 0507-1.

定义二叉树中一个结点的度数为其子结点的个数。现有一棵结点总数为 101 的二叉树，其中度数为 1 的结点数有 30 个，则度数为 0 结点有 _ _ _ _ 个。**36**





#### 0402-1.13.

由同一组关键字集合构造的各棵二叉排序树( B )。 A： 其形态不一定相同，但平均查找长度相同 B：其形态不一定相同，平均查找长度也不一定相同 C： 其形态均相同，但平均查找长度不一定相同 D： 其形态均相同，平均查找长度也都相同

#### 0402-1.15.

在映射抽象数据类型（ADT Map）的不同实现方法中，适合对动态查找表进行高效率查找的组织结构是（ C ）。 A： 有序表 B：堆排序 C： 二叉排序树 D： 快速排序

#### 0402-3.4.

一棵含有101个结点的二叉树中有36个叶子结点，度为 2 的结点个数是 _ _ _ _ 和度为１的结点个数是 _ _ _ _ 。**（35，30）**



### 3 完全二叉树

一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为**完全二叉树**。

<img src="https://bkimg.cdn.bcebos.com/pic/f9dcd100baa1cd1171faf1bdb512c8fcc2ce2dda?x-bce-process=image/format,f_auto/quality,Q_70/resize,m_lfit,limit_1,w_536" alt="img" style="zoom:50%;" />



#### 0402-3.7.

对于具有 57 个结点的完全二叉树，如果按层次自顶向下，同一层自左向右，顺序从 0 开始对全部结点进行编号，则有：编号为 18 的结点的父结点的编号是 _ _ _ _ ，编号为 19的结点的右子女结点的编号是 _ _ _ _ _ 。**（8，40）**

#### 0402-3.11.

定义完全二叉树的根结点所在层为第一层。如果一个完全二叉树的第六层有 23 个叶结点，则它的总结点数可能为？（请填写所有 3 个可能的结点数，写对 1 个得 1 分，2 个得 1.5 分，写 错 1 个不得分）。**（54，80，81）**



### 4 二叉查找树（二叉搜索树，二叉排序树，BST树）

二叉搜索树依赖于这样一个性质：小于父节点的键都在左子树中，大于父节点的键则都在右子树中。我们称这个性质为二叉搜索性

#### 在删除二叉搜索树的任意元素时，会有三种情况：

##### 1.1 删除只有左孩子的节点

节点删除之后，将左孩子所在的二叉树取代其位置；连在原来节点父亲元素右节点的位置，比如在图中需要删除`58`这个节点。

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105501621-401324023.png)

删除`58`这个节点后，如下图所示：

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105545184-1801648859.png)

##### 1.2 删除只有右孩子的节点：

节点删除之后，将右孩子所在的二叉树取代其位置；连在原来节点的位置，比如在下图中需要删除`58`这个节点。

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105612509-689754838.png)

删除58这个节点后，如下图所示：

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105627331-377768882.png)

这里需要说明说一下，以上两种情况其实包含了叶子节点情况的，我们可以把叶子节点理解成只有左孩子的节点，也可以把它理解为只有右孩子的节点，只不过左孩子、右孩子为`null`。

##### 1.3 删除包含左右孩子的节点

如下图，二叉搜索树包含有左右孩子，假设现需要删除`58`这个节点。

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105656487-1314468451.png)

针对该种情况，分析如下：
我们把`58`这个节点记为`d`节点（包含有左子树与右子树）,如下图所示：

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105710447-1464247590.png)

针对这种节点删除情况需要把左子树与右子树融合起来，融合方法：
从`d`这节点的左孩子与右孩子中找一个比`d`节点还要大的节点取代`d`节点，根据二叉搜索树的性质可知（*左边节点<当前节点<右边节点*），这个需要被找的节点存在于`d`节点的右孩子节点中。

寻找规则：
寻找需要被删除节点58(`d`)的后继的所有元素中，离 58 最近的且比 58 大的节点，在本例中为`59`这个节点【即右子树中的最小值】，记为`s`，如下图所示：

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105736759-1109724713.png)

**删除步骤：**

（1）从`d`的右子树中删除最小值，将删除最小值`s`后的`d`的右子树, 变为`d`后继节点`s`的右孩子，如下图所示：

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105800851-1324103672.png)

（2）将`d`节点（`58`节点）的左子树，变为后继节点`s`(`59`节点)的左子树，如下图所示：

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105820608-287022178.png)

(3)将后继节点`s`（`59`节点）连接到`d`节点（`58`节点）父亲节点的右边，删除`d`节点（`58`节点）后,后继`s`节点（`59`节点）成为新的根，如下图所示：

![img](https://img2018.cnblogs.com/blog/860581/201904/860581-20190412105835019-100612399.png)



#### 0507-3.

（5 分）简要回答下列 BST 树以及 BST 树更新过程的相关问题。 （1）请简述什么是二叉查找树（BST）（1 分） （2）请图示 2,1,6,4,5,3 按顺序插入一棵 BST 树的中间过程和最终形态（2 分） （3）请图示以上 BST 树，依次删除节点 4 和 2 的过程和树的形态（2 分）

答：

（1）BST 树是二叉树，对于所有的子树而言，其左子树上所有关键值都小于根，右子树上的所有关键值都大于根

（2）图片无法显示

（3）图片无法显示

#### 0402-2.7.

（ Y ）有n 个节点的二叉排序树有多种，其中树高最小的二叉排序树是搜索效率最好。

#### Sam2-1.4.

下列关于二叉搜索树的说法正确的有（ D ）。 A：从根结点一直沿右儿子向下找一定能找到该二叉搜索树值最大的结点。

B：二叉搜索树一定是满二叉树。 C：二叉搜索树一定是完全二叉树。

D：二叉搜索树按照中序遍历将各结点打印出来，将得到按照由小到大的排列。

#### **Sam2-1.18

选项中哪个插入顺序可以得到以下这棵 AVL 树（ A,B,C,D ） ？

![image-20240519212532867](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240519212532867.png)

A: 2,3,6,14,15,9 B: 9,6,3,14,2,15 C: 3,14,15,9,2,6 D: 3,14,15,9,6,2

### 5 二叉树的遍历

#### 0402-1.6.

任意一棵二叉树中，所有叶结点在前序、中序和后序周游序列中的相对次序（ B ） 。 A： 发生改变 B： 不发生改变 C： 不能确定 D： 以上都不对

#### 0402-2.5.

（ N ）若有一个叶子结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点。

#### 0402-2.6.

（ Y ）若某非空且无重复元素二叉树的先序序列和后序序列正好相同，则该二叉树只有一个根结点。

#### 0402-3.5.

已知二叉树的前序遍历结果 （先根周游序列） 为 ADC， 这棵二叉树的树型有 _ _ _ _ 种可能。**（5）**

#### 0402-3.6.

已知二叉树的中序序列为 DGBAECF，后序序列为 GDBEFCA，该二叉树的前序序列是 _ _ _ _ 。**（ABDGCEF）**

#### 0507-5.

已知某二叉树的先根周游序列为 ( A, B, D, E, C, F, G )，中根周游序列为 ( D, B, E, A, C, G, F )，则该二叉树的后根次序周游序列( _ _ _ _ )。**D,E,B,G,F,C,A**

#### 0402.5.1

已知下列 pre2post 函数的功能是根据一个满二叉树的前序遍历序列，求其后序遍历序列，请完成填空（假设序列长度不超过 32）。

```python
# 返回先根序列 preorder[start:start+length]对应的后根序列
def pre2post(preorder, start, length):
    if length == 1:
        return preorder[start]  # 1分
    else:
        length = length // 2    # 2分
        left = pre2post(preorder, start + 1, length)    # 1分
        right = pre2post(preorder, start + 1 + length, length)  # 2分
        root = preorder[start]  # 2分
        return left + right + root

print(pre2post("ABC", 0, 3))  # 输出 BCA
print(pre2post("ABDECFG", 0, 7))  # 输出 DEBFGCA
```

### 6 树的遍历

#### **树转换为二叉树**

　　由于二叉树是有序的，为了避免混淆，对于无序树，我们约定树中的每个结点的孩子结点按从左到右的顺序进行编号。

　　将树转换成二叉树的步骤是：
　　（1）加线，图例红色。就是在所有兄弟结点之间（同一层同一双亲结点的结点间）加一条连线；
　　（2）抹线。就是对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线；
　　（3）旋转。就是以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明，红色横线连起来的结点作为最左结点的**右孩子**。

![img](https://img2020.cnblogs.com/blog/2579098/202111/2579098-20211126232527593-717718785.png) ![img](https://img2020.cnblogs.com/blog/2579098/202111/2579098-20211126232543897-2010853926.png)

![img](https://img2020.cnblogs.com/blog/2579098/202111/2579098-20211126232703858-1562981388.png) ![img](https://img2020.cnblogs.com/blog/2579098/202111/2579098-20211126232931526-33969252.png)

 　　　　　　　　　　　　　　　　　　　　树转换为二叉树的过程示意图

#### 0507-4.

（ Y ）通过树的周游可以求得树的高度，若采取深度优先遍历方式设计求解树高度问题的算法，算法空间复杂度大 O 表示为 O（树的高度）。

#### 0507-5.

（ Y ）树可以等价转化二叉树，树的先序遍历序列与其相应的二叉树的前序遍历序列相同。



### 7 并查集

### 8 huffman树

#### 0402-4.2.

哈夫曼树是进行编码的一种有效方式。设给定五个字符，其相应的权值分别为 {4， 8， 6， 9， 18}，试画出相应的哈夫曼树，并计算它的带权外部路径长度 WPL 。

为了构建哈夫曼树，我们需要按照权值从小到大对字符进行排序，并不断地合并权值最小的两个节点，直到只剩下一个节点为止。这个节点就是哈夫曼树的根节点。每次合并两个节点时，新节点的权值为这两个节点的权值之和。

下面是构建哈夫曼树的过程：

1. 将给定的五个字符按照权值从小到大排序：
   1. {4， 6， 8， 9， 18}
2. 不断合并权值最小的两个节点，直到只剩下一个节点：
   1. 合并 4 和 6，得到节点 a，权值为 10
   2. 合并 8 和 9，得到节点 b，权值为 17
   3. 合并节点 a 和 b，得到节点c，权值为 27
   4. 合并节点c和 18，得到根节点d，权值为45

下面是相应的哈夫曼树：

```
          （45）
          /   \
        (27)   18
        /   \
   (10)       (17)
   /  \       /   \
  4    6     8     9
```



计算带权外部路径长度（WPL）： WPL = 4 * 3 + 6 \* 3 + 8 * 3 + 9 * 3 + 18 * 1 = 12 + 18 + 24 + 27 + 18 = 99

所以，哈夫曼树的带权外部路径长度为 99。

## 四 图

### 1 图的基本结构

无向图G的极大连通子图称为G的**连通分量**

**极大连通子图**，也称为最大连通子图，是指在给定图中不能通过添加任何顶点而保持连通性的子图。对于非连通图，极大连通子图被称为连通分量，每个连通分量都是一个连通图。例如，一个非连通图可能包含多个极大连通子图（连通分量）。在无向图中，如果加入任何一个不在图的点集中的点都会导致它不再连通，那么这个子图就是极大连通子图。

**极小连通子图**，则是指包含图中所有顶点的最小连通子图。在无向图中，如果一个子图是连通的，并且通过删除任何一条边都会使其不再连通，那么这个子图就是极小连通子图。在有向图中，强连通图的极小连通子图是其生成树，它包含了图中所有顶点且没有回路。极小连通子图只存在于连通图中，且对于同一个连通图，可能有多个不同的生成树。

**强连通**（Strongly Connected）是指一个有向图（Directed Graph）中任意两点v1、v2间存在v1到v2的路径（path）及v2到v1的路径。

**稠密图**适合使用**临接矩阵**储存，**稀疏图**适合使用**临接表**储存

#### 0402-1.9.

n 个顶点的无向完全图的边数为（ C ）。 A: n（n-1） B: n（n+1） C: n（n-1）/2 D: n（n+1）/2

#### 0402-1.10.

设无向图G= （V, E），和G’=(V’, E’)，如果 G’是 G 的生成树，则下面说法中错误的是（ B ） 。 A： G’是G 的子图 B： G’是G 的连通分量 C： G’是G 的极小连通子图且 V=V’ D： G’是G 的一个无环子图

#### 0402-2.8.

（ N ）强连通分量是有向图中的最小强连通子图。

#### Sam2-1.15.

如图所示的有向图，共有（ B ）个强连通分枝。

![image-20240519211728958](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240519211728958.png)

A: 1 B: 2 C: 4 D: 3

#### 0402-2.9.

（ Y ）用相邻接矩阵法存储一个图时，在不考虑压缩存储的情况下，所占用的存储空间大小只与图中结点个数有关，而与图的边数无关。

#### 0402-2.10.

（ N ）若定义一个有向图的根是指可以从这个结点可到达图中任意其他结点，则可知一个有向图中至少有一个根。

#### 0507-14.

今有一非连通无向图，共有 36 条边，该图至少有（ C ）个顶点。 A：8 B：9 C：10 D：11

#### 0507-15.

令 G=(V, E) 是一个无向图，若 G 中任何两个顶点之间均存在唯一的简单路径相连，则下面说 法中错误的是（ A ）。 

A：图 G 中添加任何一条边，不一定造成图包含一个环 

B：图 G 中移除任意一条边得到的图均不连通 

C： 图 G 的逻辑结构实际上退化为树结构 

D： 图 G 中边的数目一定等于顶点数目减 1

#### 0507-8.

包含 n 个顶点无向图的邻接表存储结构中，所有顶点的边表中最多有 _ _ _ _ 个结点。具有 n 个顶点的有向图，顶点入度和出度之和最大值不超过 _ _ _ _ 。**n(n-1), 2(n-1)**

#### 0402-3.10.

如果一个图节点多而边少（稀疏图），适宜采用邻接矩阵和邻接表中的 _ _ _ _ 方式进行存储。**临接表**



### 1 bfs算法

时间复杂度可以表示为O(V+E)，其中V是顶点的数量，E是边的数量。

空间复杂度通常是O(V)，因为需要一个队列来保存待访问的节点。

#### 0507-2.

在广度优先搜索算法中，一般使用什么辅助数据结构？（ A ）。 A: 队列 B: 栈 C: 树 D: 散列

### 2 dfs算法

时间复杂度：最坏情况下，DFS的时间复杂度为O(b^m)，其中b是每个节点的平均子节点数，m是树的最长路径长度。

空间复杂度：DFS的空间复杂度通常是O(h)，其中h是树的最大深度。

#### 0402-4.1.

树周游算法可以很好地应用到森林的周游上。查看下列森林结构，请给出其深度优先周游序列和广度优先周游序列。

![3901718628881_.pic](/Users/yuanlai/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/20ef5b342c28f3861251200692178fd7/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/3901718628881_.pic.jpg)

Answer:

深度优先：ADEJKFBGLCHIMN；广度优先：ABCDEFGHIJKLMN

> 森林的广度优先周游序列定义如下：
>
> 1. 从森林中的每棵树的根节点开始，将根节点加入到遍历队列中。
> 2. 从队列中取出一个节点，并将其加入到遍历结果中。
> 3. 将该节点的所有未被访问过的子节点加入到队列中。
> 4. 重复步骤2和步骤3，直到队列为空。
>
> 在广度优先周游序列中，每一层的节点按照从左到右的顺序加入到遍历结果中。这确保了每棵树的每一层都会被遍历到，而且同一层的节点会按照从左到右的顺序被遍历。

#### 0402.5.2

阅读下列程序，完成图的深度优先周游算法实现的迷宫探索。已知图采用邻接表表示，Graph 类和 Vertex 类基本定义如下：

```python
class Graph:
    def __init__(self):
        self.vertices = {}

    def addVertex(self, key, label): #添加节点，id 为key，附带数据 label
        self.vertices[key] = Vertex(key, label)

    def getVertex(self, key): # 返回 id 为 key 的节点
        return self.vertices.get(key)

    def __contains__(self, key): # 判断 key 节点是否在图中
        return key in self.vertices

    def addEdge(self, f, t, cost=0): # 添加从节点 id==f 到 id==t 的边
        if f in self.vertices and t in self.vertices:
            self.vertices[f].addNeighbor(t, cost)

    def getVertices(self): # 返回所有的节点 key
        return self.vertices.keys()

    def __iter__(self): # 迭代每一个节点对象
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key, label=None): # 缺省颜色为"white“
        self.id = key
        self.label = label
        self.color = "white"
        self.connections = {}

    def addNeighbor(self, nbr, weight=0): # 添加到节点 nbr 的边
        self.connections[nbr] = weight

    def setColor(self, color): # 设置节点颜色标记
        self.color = color

    def getColor(self): # 返回节点颜色标记
        return self.color

    def getConnections(self): # 返回节点的所有邻接节点列表
        return self.connections.keys()

    def getId(self): # 返回节点的 id
        return self.id

    def getLabel(self): # 返回节点的附带数据 label
        return self.label

#https://github.com/Yuqiu-Yang/problem_solving_with_algorithms_and_data_structures_using_python/blob/master/ch7/ch4_maze2.txt
mazelist = [
    "++++++++++++++++++++++",
    "+   +   ++ ++        +",
    "E     +     ++++++++++",
    "+ +    ++  ++++ +++ ++",
    "+ +   + + ++    +++  +",
    "+          ++  ++  + +",
    "+++++ + +      ++  + +",
    "+++++ +++  + +  ++   +",
    "+          + + S+ +  +",
    "+++++ +  + + +     + +",
    "++++++++++++++++++++++",
]

def mazeGraph(mlist, rows, cols): # 从 mlist 创建图，迷宫有 rows 行 cols 列
    mGraph = Graph()
    vstart = None
    for row in range(rows):
        for col in range(cols):
            if mlist[row][col] != "+":
                mGraph.addVertex((row, col), mlist[row][col])
                if mlist[row][col] == "S":
                    vstart = mGraph.getVertex((row, col)) # 等号右侧填空（1分）

    for v in mGraph:
        row, col = v.getId()
        for i in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            if 0 <= row + i[0] < rows and 0 <= col + i[1] < cols:
                if (row + i[0], col + i[1]) in mGraph:
                    mGraph.addEdge((row, col), (row + i[0], col + i[1])) #括号中两个参数填空（1分）

    return mGraph, vstart # 返回图对象，和开始节点


def searchMaze(path, vcurrent, mGraph): # 从 vcurrent 节点开始 DFS 搜索迷宫，path 保存路径
    path.append(vcurrent.getId())
    vcurrent.setColor("gray")
    if vcurrent.getLabel() != "E":
        done = False
        for nbr in vcurrent.getConnections(): # in 后面部分填空（2分）
            nbr_vertex = mGraph.getVertex(nbr)
            if nbr_vertex.getColor() == "white":
                done = searchMaze(path, nbr_vertex, mGraph) # 参数填空（2分）
                if done:
                    break
        if not done:
            path.pop() # 这条语句空着，填空（2分）
            vcurrent.setColor("white")
    else:
        done = True
    return done # 返回是否成功找到通路


g, vstart = mazeGraph(mazelist, len(mazelist), len(mazelist[0]))
path = []
searchMaze(path, vstart, g)
print(path)

# [(8, 15), (7, 15), (7, 14), (6, 14), (5, 14), (4, 14), (4, 13), (5, 13), (6, 13), (6, 12), (6, 11), (6, 10), (5, 10), (5, 9), (4, 9), (3, 9), (2, 9), (2, 8), (2, 7), (1, 7), (1, 6), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (5, 4), (4, 4), (3, 4), (2, 4), (2, 3), (1, 3), (1, 2), (2, 2), (2, 1), (2, 0)]
```

#### **Sam2-1.16.

在下图中，从顶点 A 出发进行深度优先遍历可得到的序列是（ A,B,D ）。

![image-20240519211933166](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240519211933166.png)

A: ABDCG B: ACBDG C: ADBGC D: ADBCG

### 2 拓扑排序

#### 0507-4.2

（5 分）有八项活动，每项活动标记为 V+编号 n(0<=n<=7)，每项活动要求的前驱如下:

| 活动 | V0     | V1   | V2   | V3     | V4   | V5     | V6   | V7     |
| ---- | ------ | ---- | ---- | ------ | ---- | ------ | ---- | ------ |
| 前驱 | 无前驱 | V0   | V0   | V0, V2 | V1   | V2, V4 | V3   | V5, V6 |

（1）画出相应的 AOV（Active On Vertex）网络（即节点为活动，边为先后关系的有向图）， （2）并给出一个拓扑排序序列，如存在多种，则按照编号从小到大排序，输出最小的一种。

答：

（1）AOV网络

![3911718642778_.pic](/Users/yuanlai/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/20ef5b342c28f3861251200692178fd7/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/3911718642778_.pic.jpg)（2)其中一个序列为：V0,V1,V2,V3,V4,V5,V6,V7

#### 0507-1.

（6 分）拓扑排序：给定一个有向图，求拓扑排序序列。

输入：第一行是整数 n，表示图有 n 顶点 (1<=n<=100)，编号 1 到 n。接下来 n 行，第 i 行列了顶点 i 的所有邻点，以 0 结尾。没有邻点的顶点，对应行就是单独一个0。

输出：一个图的拓扑排序序列。如果图中有环，则输出“Loop”。

样例输入 (#及其右边的文字是说明，不是输入的一部分)：

```
5 					#5 个顶点
0 					#1 号顶点无邻点
4 5 1 0 		#2 号顶点有邻点 4 5 1
1 0
5 3 0
3 0
```



样例输出

```
2 4 5 3 1
```



请对下面的解题程序进行填空

```python
class Edge: # 表示邻接表中的图的边,v 是终点
    def __init__(self, v):
        self.v = v


def topoSort(G):    # G 是邻接表，顶点从 0 开始编号
    # G[i][j]是 Edge 对象，代表边 <i, G[i][j].v>
    n = len(G)
    import queue
    inDegree = [0] * n  # inDegree[i]是顶点 i 的入度
    q = queue.Queue()
    # q 是队列, q.put(x)可以将 x 加入队列，q.get()取走并返回对头元素
    # q.empty()返回队列是否为空

    for i in range(n):
        for e in G[i]:
            inDegree[e.v] += 1  # 【1 分】

    for i in range(n):
        if inDegree[i] == 0:
            q.put(i)    # 【1 分】

    seq = []
    while not q.empty():
        k = q.get()
        seq.append(k)   # 【1 分】
        for e in G[k]:
            inDegree[e.v] -= 1  # 【1 分】
            if inDegree[e.v] == 0:
                q.put(e.v)  # 【1 分】

    if len(seq) != n:   # 【1 分】
        return None
    else:
        return seq


n = int(input())
G = [[] for _ in range(n)]  # 邻接表
for i in range(n):
    lst = list(map(int, input().split()))
    print(lst)
    G[i] = [Edge(x - 1) for x in lst[:-1]]
    print(G[i])

result = topoSort(G)
if result is not None:
    for x in result:
        print(x + 1, end=" ")
else:
    print("Loop")
```

#### 0507-3.

（7 分）无向图判定：给定一个无向图，判断是否连通，是否有回路。 输入：第一行两个整数 n,m，分别表示顶点数和边数。顶点编号从 0 到 n-1。 (1<=n<=110, 1<=m<= 10000) 接下来 m 行，每行两个整数 u 和 v，表示顶点 u 和 v 之间有边。

输出: 如果图是连通的，则在第一行输出“connected:yes",否则第一行输出“connected:no"。 如果图中有回路，则在第二行输出“loop:yes ",否则第二行输出“loop:no"。

样例输入

```
3 2
0 1
0 2
```



样例输出

```
connected:yes
loop:no
```



请进行程序填空：

```python
def isConnected(G): # G 是邻接表,顶点编号从 0 开始，判断是否连通
    n = len(G)
    visited = [False for _ in range(n)]
    total = 0

    def dfs(v):
        nonlocal total
        visited[v] = True
        total += 1
        for u in G[v]:
            if not visited[u]:
                dfs(u)

    dfs(0)
    return total == n      # 【2 分】

def hasLoop(G): # G 是邻接表,顶点编号从 0 开始，判断有无回路
    n = len(G)
    visited = [False for _ in range(n)]

    def dfs(v, x): # 返回值表示本次 dfs 是否找到回路,x 是深度优先搜索树上 v 的父结点
        visited[v] = True
        for u in G[v]:
            if visited[u] == True:
                if u != x: # 【2 分】
                    return True
            else:
                if dfs(u, v):   # 【2 分】
                    return True
        return False

    for i in range(n):
        if not visited[i]:  # 【1 分】
            if dfs(i, -1):
                return True
    return False

n, m = map(int, input().split())
G = [[] for _ in range(n)]
for _ in range(m):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)

if isConnected(G):
    print("connected:yes")
else:
    print("connected:no")

if hasLoop(G):
    print("loop:yes")
else:
    print("loop:no")
```

#### Sam2-1.17.

如图所示的 DAG 图，其拓扑排序序列为（ B ）。

![image-20240519212238466](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240519212238466.png)

A: ADGBC B: ADBGC C: AGBDC D: ACDGB

### 3 dijkstra算法

求从一个点到另一个点的最短路径

用一个堆存储到该顶点的距离，然后不断pop最小值并存储为真正的最小距离，直到查到想找的点

负权值边无效

#### 0507-10.

（ Y ）Dijkstra 算法的局限性是无法正确求解带有负权值边的图的最短路径。

#### Sam2-1.19.

下列关于最短路算法的说法正确的有（ A, C ） ：

A: 当图中不存在负权回路但是存在负权边时， Dijkstra 算法不一定能求出源点到所有点的最短路。

B: 当图中存在负权回路时， Dijkstra 算法也一定能求出源点到所有点的最短路。 C: 当图中不存在负权边时， Dijkstra 算法能求出每对顶点间最短路径. D: Dijkstra 算法不能用于每对顶点间最短路计算。

### 4 最小生成树

一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 [1]最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。

**Kruskal 算法（适合稀疏图）**

- Kruskal算法是一种用于解决最小生成树（MST）问题的贪心算法。它通过不断选择具有最小权重的边，并确保选择的边不形成环，最终构建出一个包含所有顶点的最小生成树。
- 在Kruskal算法中，通常会使用并查集来维护图中顶点的连通性信息。当选择一条边时，通过并查集判断该边的两个端点是否属于同一个连通分量，以避免形成环。
- 并查集优化：$O(Elog V)$

**Prim 算法（适合稠密图）**：

找从A开始的最小生成树，不断往里面加与之相连的最小权重边

- 邻接矩阵 + 简单数组：$O(V^2)$
- 邻接表 + 二叉堆：$O(Elog V)$
- 邻接表 + 斐波那契堆：$O(Vlog V + E)$

#### 0507-7.

（ Y ）求解最小生成树问题的 Prim 算法是一种贪心算法。

#### 0507-3.

（ N ）对任意一个连通的无向图，如果存在一个环，且这个环中的一条边的权值不小于该环中任意一个其它的边的权值，那么这条边一定不会是该无向图的最小生成树中的边。

#### 0507-6.

（ Y ）如果一个连通无向图 G 中所有边的权值均不同，则 G 具有唯一的最小生成树。

#### 0507-7.

51 个顶点的连通图 G 有 50 条边，其中权值为 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 的边各 5 条，则连通图 G 的最小生成树各边的权值之和为 _ _ _ _ _ 。**275**

#### 0402-4.4.

已知图 G 的顶点集合 V={V0, V1, V2, V3, V4}，邻接矩阵如下图所示， 可用 prim 算法求 G 的最小生成树。 $$ \left[ \matrix{ 0 & 7 & \infty & 4 & 2 \ 7 & 0 & 9 & 1 & 5 \ \infty & 9 & 0 & 3 & \infty \ 4 & 1 & 3 & 0 & 10 \ 2 & 5 & \infty & 10 & 0 } \right] $$

1） 根据邻接矩阵， 画出图 G（2 分）； 2） 根据 prim 算法，求图 G 从顶点 V0 出发的最小生成树（2 分）； 3） 用图表示出最小生成树每一步的生成过程（2 分） 。

## 总结

笔试部分更多的考察对数据结构与算法的一些宏观概念和知识的理解。

与机考部分的内容存在一一对应关系，在此不多赘述。

本文对三套笔试题目进行了分类总结，并加入了一些个人理解与在网络上检索到的相关知识以便理解。