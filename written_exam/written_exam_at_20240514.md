# 20240514 数算B-12班-笔试（模考）

Updated 1510 GMT+8 May 11, 2024

2024 spring, Complied by Hongfei Yan



说明：

1）2024/5/14 15:00～17:00，笔试，线下理教410教室有x人+线上y人。

2）周二5月14日15:00～17:00，课堂上进行笔试（电脑上完成），考题在canvas平台，届时开放。

题目包括：选择、判断、填空、简答、算法填空；有的题目需要拍照上传。

请大家带笔记本（pad没有试过，估计也可以），草稿纸，cheat paper，个人独立完成。

预计考100分题目，包括：15个选择题30分，10个判断题10分，10个填空题（改造为选择形式）20分，3个简答14分，4个算法26分。期末考试是120分钟，我们利用两节课加课间时间120分钟完成。

不计分。笔试后再上课，可能线下/线上同学顺序来讲解题目，每人一个。讲解时候（最好到讲台），先介绍下自己的姓名、院系，复述一下题面，然后讲解该题目答案。

笔试范围包括：栈、队列、优先队列、排序、散列表、哈夫曼、调度场、各种树的定义、操作（如各种遍历），时间复杂度、图等。



# 一．选择题（30 分，每小题 2 分）

1. 双向链表中的每个结点有两个引用域，prev 和 next，分别引用当前结点的前驱与后继，设 p 引用链表中的一个结点，q 引用一待插入结点，现要求在 p 前插入 q，则正确的插入操作为（ D  ）。

   A：p.prev=q; q.next=p; p.prev.next=q; q.prev=p.prev;
   B：q.prev=p.prev; p.prev.next=q; q.next=p; p.prev=q.next;
   C：q.next=p; p.next=q; p.prev.next=q; q.next=p;
   **D：p.prev.next=q; q.next=p; q.prev=p.prev; p.prev=q.**

   

   假设链表是 ![$A <-> B <-> C$](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAtJREFUGFdjYAACAAAFAAGq1chRAAAAAElFTkSuQmCC)*A*<−>*B*<−>*C*，要在 B 前插入 Q，那么会得到 ![$A <-> Q <-> B <-> C $](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAtJREFUGFdjYAACAAAFAAGq1chRAAAAAElFTkSuQmCC)*A*<−>*Q*<−>*B*<−>*C*的链表。这是在结点 B 前插入 Q 结点的步骤：

   1. `p.prev.next = q;` 这一步是把 p 的前一个结点的 next 指针指向 q。在例子中，是把 A 的 next 指针指向 Q。
   2. `q.next = p;` 这一步是把 q 的 next 指针指向 p。在例子中，是把 Q 的 next 指针指向 B。
   3. `q.prev = p.prev;` 这一步是把 q 的 prev 指针指向 p 的前一个结点。在例子中，是把 Q 的 prev 指针指向 A。
   4. `p.prev = q;` 这一步是把 p 的 prev 指针指向 q。在例子中，是把 B 的 prev 指针指向 Q。

2. 给定一个 N 个相异元素构成的有序数列，设计一个递归算法实现数列的二分查找，考察递归过程中栈的使用情况，请问这样一个递归调用栈的最小容量应为（ C ）。
   A：N	B：N/2	C：$\lceil \log_{2}(N) \rceil$	D：$\lceil \log_{2}(N+1) \rceil$​

   

   解释：对于二分查找的递归实现，每次递归调用都会将问题规模减半，因此递归的深度就是问题规模的对数级别。在最坏情况下，递归的深度达到log2(N)。每次递归调用会占用栈空间，而栈的使用情况可以通过递归调用的最大深度来估计。因此，递归调用栈的最小容量应为最大递归深度的值。

   根据给定的有序数列，共有N个相异元素，二分查找的递归深度为log2(N)。但是栈的容量必须能够容纳递归深度的最大值，所以栈的最小容量应为「上取整」，答案是C。

3. 数据结构有三个基本要素:逻辑结构、存储结构以及基于结构定义的行为(运算)。下列概念中( B )属于存储结构。
   A:线性表	B:**链表**	C:字符串	D:二叉树

   

   解释：在这些选项中，有些描述的是数据的逻辑结构，而有些是存储结构。逻辑结构指的是数据对象中数据元素之间的相互关系，而存储结构是指数据结构在计算机中的表示（也就是内存中的存储形式）。

   A: **线性表** - 这是一种逻辑结构，它描述元素按线性顺序排列的规则。
   B: 链表 - 这是一种存储结构，它是线性表的链式存储方式，通过节点的相互链接来实现。

   正确答案是 B: 链表，因为它指的是数据的物理存储方式，即内存中的链式存储结构。

4. 为了实现一个循环队列（或称环形队列），采用数组 Q[0..m-1]作为存储结构,其中变量 rear 表示这个循环队列中队尾元素的实际位置，添加结点时按 rear=(rear+1) % m 进行指针移动，变量length 表示当前队列中的元素个数，请问这个循环队列的队列首位元素的实际位置是（ B ）。
   A：rear-length	B：(1+rear+m-length) % m	C：(rear-length+m) % m	D：m-length

   

   length = rear - head + 1，再对环形队列的特点做调整，得到B。 

5. 给定一个二叉树，若前序遍历序列与中序遍历序列相同，则二叉树是（ D ）。
   A：根结点无左子树的二叉树
   B：根结点无右子树的二叉树
   C：只有根结点的二叉树或非叶子结点只有左子树的二叉树
   **D：**只有根结点的二叉树或非叶子结点只有右子树的二叉树

   因为在前序遍历中，根节点总是首先访问的，而在中序遍历中，根节点必然在中间。

6. 用 Huffman 算法构造一个最优二叉编码树，待编码的字符权值分别为{3，4，5，6，8，9，11，12}，请问该最优二叉编码树的带权外部路径长度为（ B ）。（补充说明：树的带权外部路径长度定义为树中所有叶子结点的带权路径长度之和；其中，结点的带权路径长度定义为该结点到树根之间的路径长度与该结点权值的乘积）（ B ）
   A：58	B：169	C：72	D：18

   

   解释：为了构造哈夫曼树，我们遵循一个重复的选择过程，每次选择两个最小的权值创建一个新的节点，直到只剩下一个节点为止。我们可以按照以下步骤操作：

   1. 将给定的权值排序：{3, 4, 5, 6, 8, 9, 11, 12}。

   2. 选择两个最小的权值：3 和 4，将它们组合成一个新的权值为 7 的节点。

      现在权值变为：{5, 6, 7, 8, 9, 11, 12}。

   3. 再次选择两个最小的权值：5 和 6，将它们组合成一个新的权值为 11 的节点。

      现在权值变为：{7, 8, 9, 11, 11, 12}。

   4. 选择两个最小的权值：7 和 8，将它们组合成一个新的权值为 15 的节点。

      现在权值变为：{9, 11, 11, 12, 15}。

   5. 选择两个最小的权值：9 和 11，将它们合并成一个新的权值为 20 的节点。

      现在权值变为：{11, 12, 15, 20}。

   6. 选择两个最小的权值：11 和 12，合并成一个新的权值为 23 的节点。

      现在权值变为：{15, 20, 23}。

   7. 选择两个最小的权值：15 和 20，合并成一个新的权值为 35 的节点。

      现在权值变为：{23, 35}。

   8. 最后，合并这两个节点得到根节点，权值为 23 + 35 = 58。

   现在我们可以计算哈夫曼树的带权外部路径长度（WPL）。

   ```
             (58)
           /      \
        (23)       (35)
        /  \       /   \
      (11)(12)  (20)    (15) 
                / \       / \
               (9)(11)   (7)(8)
                   / \   / \  
                  (5)(6)(3) (4)
   ```

   现在让我们计算每个叶子节点的带权路径长度：

   - 权值 3 的节点路径长度为 4，WPL部分为 3 * 4 = 12。
   - 权值 4 的节点路径长度为 4，WPL部分为 4 * 4 = 16。
   - 权值 5 的节点路径长度为 4，WPL部分为 5 * 4 = 20。
   - 权值 6 的节点路径长度为 4，WPL部分为 6 * 4 = 24。
   - 权值 9 的节点路径长度为 3，WPL部分为 9 * 3 = 27。
   - 权值 8 的节点路径长度为 3，WPL部分为 8 * 3 = 24。
   - 权值 11 的节点路径长度为 2，WPL部分为 11 * 2 = 22。
   - 权值 12 的节点路径长度为 2，WPL部分为 12 * 2 = 24。

   将所有部分的 WPL 相加，我们得到整棵哈夫曼树的 WPL：

   WPL = 12 + 16 + 20 + 24 + 27 + 24 + 22 + 24 = 169

7. 假设需要对存储开销 1GB (GigaBytes) 的数据进行排序，但主存储器（RAM）当前可用的存储空间只有 100MB (MegaBytes)。针对这种情况，（ B ）排序算法是最适合的。
   A：堆排序	B：**归并排序**	C：快速排序	D：插入排序

   

   解释：对于这种情况，最适合的排序算法是归并排序（B）。

   归并排序是一种外部排序算法，它的主要思想是将数据分成较小的块，然后逐步合并这些块以获得有序的结果。由于主存储器的可用空间有限，归并排序非常适合这种情况，因为它可以在有限的主存中进行部分排序，并将排序好的部分写入外部存储（磁盘）中。然后再将不同部分进行合并，直到得到完全排序的结果。

   堆排序（A）通常需要对整个数据集进行排序，因此不适合主存储器有限的情况。

   快速排序（C）通常是一种原地排序算法，它需要频繁地交换数据，这可能导致频繁的磁盘访问，不适合主存储器有限的情况。

   插入排序（D）的时间复杂度较低，但它需要频繁地移动数据，这可能导致频繁的磁盘访问，也不适合主存储器有限的情况。

8. 已知一个无向图 G 含有 18 条边，其中度数为 4 的顶点个数为 3，度数为 3 的顶点个数为 4，其他顶
   点的度数均小于 3，请问图 G 所含的顶点个数至少是（ C ）。
   A: 10    B: 11    C: 13    D: 15

9. 给定一个无向图 G，从顶点 V0 出发进行无向图 G 的深度优先遍历，访问的边集合为： {(V0,V1),
   (V0,V4), (V1,V2), (V1,V3), (V4,V5), (V5,V6)}，则下面哪条边（ C ）不能出现在 G 中？
   A: (V0, V2)      B: (V4, V6)
   C: (V4, V3)      D: (V0, V6)

10. 已知一个有向图 G 的邻接入边表（或称逆邻接表）如下图所示，从顶点 v0 出发对该图 G 进行深度
    优先周游，得到的深度优先周游结点序列为（ B ）。
    A： V0V1V4V3V2   B：V0V1V2V3V4    C：V0V1V3V2V4. D：V0V2V1V3V4

    <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240511155818050.png" alt="image-20240511155818050" style="zoom:50%;" />

    

11. 若按照排序的稳定性和不稳定性对排序算法进行分类，则（ D ）是不稳定排序。
    A：冒泡排序	B：归并排序	C：直接插入排序	D：**希尔排序**

    

    解释：根据排序算法的稳定性，如果需要选择一个不稳定排序算法，选项D：希尔排序是正确的选项。

    稳定排序算法是指，当有两个相等的元素A和B，且在排序前A出现在B的前面，在排序后A仍然会出现在B的前面。而不稳定排序算法则无法保证这种相对顺序。

    冒泡排序（A）和直接插入排序（C）都属于稳定排序算法，它们在比较和交换元素时会考虑相等元素的顺序关系。

    归并排序（B）是一种稳定排序算法，它通过分治的思想将待排序的序列划分为较小的子序列，然后逐步合并这些子序列并保持相对顺序。

    希尔排序（D）是一种不稳定排序算法，它使用间隔序列来对数据进行分组，然后对每个分组进行插入排序。在插入排序的过程中，相等元素的顺序可能会发生变化。

12. 以下（ C ）分组中的两个排序算法的最坏情况下时间复杂度的大 O 表示相同。
    A：快速排序和堆排序 B：归并排序和插入排序 C：**快速排序和选择排序** D：堆排序和冒泡排序

    

    解释：选项C：快速排序和选择排序中的两个排序算法的最坏情况下时间复杂度的大 O 表示相同。

    快速排序和选择排序都属于不同的排序算法，但它们的最坏情况下的时间复杂度都是O(n^2)。

    快速排序的最坏情况下时间复杂度发生在每次选择的基准元素都划分出了一个很小的子序列，使得递归的深度达到了n，导致时间复杂度为O(n^2)。

    选择排序的最坏情况下时间复杂度发生在每次选择最小（或最大）元素时，需要遍历未排序部分的所有元素，导致时间复杂度为O(n^2)。

13. 设结点 X 和 Y 是二叉树中任意的两个结点，在该二叉树的先根周游遍历序列中 X 出现在 Y 之前，而在其后根周游序列中 X 出现在 Y 之后，则 X 和 Y 的关系是（ C ）。
    A：X 是 Y 的左兄弟    B：X 是 Y 的右兄弟
    C：X 是 Y 的祖先    D：X 是 Y 的后裔

14. 考虑一个森林 F，其中每个结点的子结点个数均不超过 2。如果森林 F 中叶子结点的总个数为 L，度数为 2 结点（子结点个数为 2）的总个数为 N，那么当前森林 F 中树的个数为（ B ）。
    A：L-N-1    B：无法确定    C：L-N    D：N-L

15. 回溯法是一类广泛使用的算法，以下叙述中不正确的是（ C ）。
    A：回溯法可以系统地搜索一个问题的所有解或者任意解
    B：回溯法是一种既具备系统性又具备跳跃性的搜索算法
    C：回溯算法需要借助队列数据结构来保存从根结点到当前扩展结点的路径
    D：回溯算法在生成解空间的任一结点时，先判断当前结点是否可能包含问题的有效解，如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向祖先结点回溯





# 二．判断

（10 分，每小题 1 分；对填写“Y”, 错填写“N” ）

1. （ ）按照前序、中序、后序方式周游一棵二叉树，分别得到不同的结点周游序列，然而三种不同的周游序列中，叶子结点都将以相同的顺序出现。
2. （ ）构建一个含 N 个结点的（二叉）最小值堆，时间效率最优情况下的时间复杂度大 O 表示为 O (N Log N)。
3. （ ）对任意一个连通的无向图，如果存在一个环，且这个环中的一条边的权值不小于该环中任意一个其它的边的权值，那么这条边一定不会是该无向图的最小生成树中的边。
4. （ ）通过树的周游可以求得树的高度，若采取深度优先遍历方式设计求解树高度问题的算法，算法空间复杂度大 O 表示为 O（树的高度）。
5. （ ）树可以等价转化二叉树，树的先序遍历序列与其相应的二叉树的前序遍历序列相同。
6. （ ）如果一个连通无向图 G 中所有边的权值均不同，则 G 具有唯一的最小生成树。
7. （ ）求解最小生成树问题的 Prim 算法是一种贪心算法。
8. （ ）使用线性探测法处理散列表碰撞问题，若表中仍有空槽（空单元），插入操作一定成功。
9. （ ）从链表中删除某个指定值的结点，其时间复杂度是 O(1)。
10. （ ）Dijkstra 算法的局限性是无法正确求解带有负权值边的图的最短路径。





# 三．填空（20 分，每题 2 分）

1. 定义二叉树中一个结点的度数为其子结点的个数。现有一棵结点总数为 101 的二叉树，其中度数为 1 的结点数有 30 个，则度数为 0 结点有 _ _ _ _ 个。

2. 定义完全二叉树的根结点所在层为第一层。如果一个完全二叉树的第六层有 23 个叶结点，则它的总结 点数可能为 _ _ _ _ （请填写所有 3 个可能的结点数，写对 1 个得 1 分，2 个得 1.5 分，写 错 1 个不得分）。

3. 对于初始排序码序列（51, 41, 31, 21, 61, 71, 81, 11, 91），用双指针原地交换实现，第 1 趟快速排序（以第一个数字为中值）的结果是： _ _ _ _ 

4. 如果输入序列是已经正序，在(改进)冒泡排序、直接插入排序和直接选择排序算算法中， _ _ _ _ 算法最慢结束。

5. 已知某二叉树的先根周游序列为 ( A，B，D，E，C，F，G )，中根周游序列为 ( D，B，E，A，C，G，F )，则该二叉树的后根次序周游序列(  _ _ _ _  )。

6. 使用栈计算后缀表达式 (操作数均为一位数) “1 2 3 + 4 * 5 + 3 + −” ，当扫描到第二个+号但还未对该+号进行运算时，栈的内容 (以栈底到栈顶从左往右的顺序书写) 为 _ _ _ _ 。

7. 51 个顶点的连通图 G 有 50 条边，其中权值为 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 的边各 5 条，则连通图 G 的最小生成树各边的权值之和为 _ _ _ _ _ 。

8. 包含 n 个顶点无向图的邻接表存储结构中，所有顶点的边表中最多有 _ _ _ _ 个结点。具有 n 个顶点的有向图，顶点入度和出度之和最大值不超过 _ _ _ _ 。

9. 给定一个长度为 7 的空散列表，采用双散列法解决冲突，两个散列函数分别为：h1(key) = key % 7，h2(key) = key%5 + 1 请向散列表依次插入关键字为 30, 58, 65 的集合元素，插入完成后 65 在散列表中存储地址为 _ _ _ _ _ 。

10. 阅读算法 ABC，回答问题。

    ```python
    def ABC(n):
      k, m = 2, int(n**0.5)
      while (k <= m) and (n %k != 0):
        k += 1
      return k > m
    ```

    1）算法的功能是：_ _ _ _ 。

    2）算法的时间复杂度是O( _ _ _ _ )。





# 四．简答（3题，共14分）

1. （4 分）字符串匹配算法从长度为 n 的文本串 S 中查找长度为 m 的模式串 P 的首次出现。

  a）字符串匹配的朴素算法使用暴力搜索，大致过程如下：对于 P 在 S 中可能出现的 n-m+1 个位置，比对此位置时 P 和 S 中对应子串是否相等。其时间复杂度 O((n-m+1)m)。请举例说明算法时间复杂度一种最坏情况（注：例子中请只出现 a 和 b 两种字符）。（1分）

  b）已知字符串 S 为“abaabaabaabcc”，模式串 t 为“abaabc”。采用朴素算法进行查找，请写出字符比对的总次数和查找结果。（2 分）

  c）朴素算法存在很大的改进空间，说明在上述(b)步骤中，第一次出现不匹配（s[i+j] != t[j]）时（i=0, j=5），为了避免冗余比对，则下次比对时，i 和 j 的值可以分别调整为多少？（1分）

  

  字符串匹配的朴素算法：

  ```python
  def issubstring(s, t):
      for i in range(len(s)):
          for j in range(len(t)):
              if s[i + j] != t[j]:
                  break
          else:
              return True
      return False
  ```

  

2. （5 分）有八项活动，每项活动标记为 V+编号 n(0<=n<=7)，每项活动要求的前驱如下:

  | 活动 | V0     | V1   | V2   | V3     | V4   | V5     | V6   | V7     |
  | ---- | ------ | ---- | ---- | ------ | ---- | ------ | ---- | ------ |
  | 前驱 | 无前驱 | V0   | V0   | V0, V2 | V1   | V2, V4 | V3   | V5, V6 |

  （1）画出相应的 AOV（Active On Vertex）网络（即节点为活动，边为先后关系的有向图），
  （2）并给出一个拓扑排序序列，如存在多种，则按照编号从小到大排序，输出最小的一种。



3. （5 分）简要回答下列 BST 树以及 BST 树更新过程的相关问题。
   （1）请简述什么是二叉查找树（BST）（1 分）
   （2）请图示 2,1,6,4,5,3 按顺序插入一棵 BST 树的中间过程和最终形态（2 分）
   （3）请图示以上 BST 树，依次删除节点 4 和 2 的过程和树的形态（2 分）





# 五．算法填空（4题，共26分）

1. （6 分）拓扑排序：给定一个有向图，求拓扑排序序列。

输入：第一行是整数 n，表示图有 n 顶点 (1<=n<=100)，编号 1 到 n。接下来 n 行，第 i 行列了顶点 i 的所有邻点，以 0 结尾。没有邻点的顶点，对应行就是单独一个0。

输出：一个图的拓扑排序序列。如果图中有环，则输出“Loop”。

样例输入 (#及其右边的文字是说明，不是输入的一部分)：

  ```
  5 					#5 个顶点
  0 					#1 号顶点无邻点
  4 5 1 0 		#2 号顶点有邻点 4 5 1
  1 0
  5 3 0
  3 0
  ```

样例输出

  ```
  2 4 5 3 1
  ```

请对下面的解题程序进行填空



```python
class Edge: # 表示邻接表中的图的边,v 是终点
    def __init__(self, v):
        self.v = v


def topoSort(G):    # G 是邻接表，顶点从 0 开始编号
    # G[i][j]是 Edge 对象，代表边 <i, G[i][j].v>
    n = len(G)
    import queue
    inDegree = [0] * n  # inDegree[i]是顶点 i 的入度
    q = queue.Queue()
    # q 是队列, q.put(x)可以将 x 加入队列，q.get()取走并返回对头元素
    # q.empty()返回队列是否为空

    for i in range(n):
        for e in G[i]:
            _______________  # 【1 分】

    for i in range(n):
        if inDegree[i] == 0:
            _______________    # 【1 分】

    seq = []
    while not q.empty():
        k = q.get()
        seq.append(k)   # 【1 分】
        for e in G[k]:
            _______________  # 【1 分】
            if inDegree[e.v] == 0:
                _______________  # 【1 分】

    if _______________:   # 【1 分】
        return None
    else:
        return seq


n = int(input())
G = [[] for _ in range(n)]  # 邻接表
for i in range(n):
    lst = list(map(int, input().split()))
    print(lst)
    G[i] = [Edge(x - 1) for x in lst[:-1]]
    print(G[i])

result = topoSort(G)
if result is not None:
    for x in result:
        print(x + 1, end=" ")
else:
    print("Loop")

```



2. （7 分）链表操作：读入一个从小到大排好序的整数序列到链表，然后在链表中删除重复的元素，使得重复的元素只保留 1 个，然后将整个链表内容输出。

输入样例：

  ```
  1 2 2 2 3 3 4 4 6
  ```

输出样例:

  ```
  1 2 3 4 6
  ```

请对程序填空:



```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

a = list(map(int, input().split()))
head = Node(a[0])
p = head
for x in a[1:]:
    _______________    # 【2 分】
    p = p.next

p = head
while p:
    while _______________ and p.data == p.next.data: # 【2 分】
        _______________    #【1 分】
    p = p.next

p = head
while p:
    print(p.data, end=" ")
    _______________  # 【2 分】

```



3. （7 分）无向图判定：给定一个无向图，判断是否连通，是否有回路。
输入：第一行两个整数 n,m，分别表示顶点数和边数。顶点编号从 0 到 n-1。 (1<=n<=110, 1<=m<= 10000) 接下来 m 行，每行两个整数 u 和 v，表示顶点 u 和 v 之间有边。

输出:
如果图是连通的，则在第一行输出“connected:yes",否则第一行输出“connected:no"。
如果图中有回路，则在第二行输出“loop:yes ",否则第二行输出“loop:no"。

样例输入

  ```
  3 2
  0 1
  0 2
  ```

样例输出

  ```
  connected:yes
  loop:no
  ```

请进行程序填空：



```python
def isConnected(G): # G 是邻接表,顶点编号从 0 开始，判断是否连通
    n = len(G)
    visited = [False for _ in range(n)]
    total = 0

    def dfs(v):
        nonlocal total
        visited[v] = True
        total += 1
        for u in G[v]:
            if not visited[u]:
                dfs(u)

    dfs(0)
    return _______________      # 【2 分】

def hasLoop(G): # G 是邻接表,顶点编号从 0 开始，判断有无回路
    n = len(G)
    visited = [False for _ in range(n)]

    def dfs(v, x): # 返回值表示本次 dfs 是否找到回路,x 是深度优先搜索树上 v 的父结点
        visited[v] = True
        for u in G[v]:
            if visited[u] == True:
                if _______________: # 【2 分】
                    return True
            else:
                if _______________:   # 【2 分】
                    return True
        return False

    for i in range(n):
        if _______________:  # 【1 分】
            if dfs(i, -1):
                return True
    return False

n, m = map(int, input().split())
G = [[] for _ in range(n)]
for _ in range(m):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)

if isConnected(G):
    print("connected:yes")
else:
    print("connected:no")

if hasLoop(G):
    print("loop:yes")
else:
    print("loop:no")

```





4. （6 分）堆排序：输入若干个整数，下面的程序使用堆排序算法对这些整数从小到大排序，请填空。
程序中建立的堆是大顶堆（最大元素在堆顶）

输入样例：

  ```
  1 3 43 8 7
  ```

输出样例:

  ```
  1 3 7 8 43
  ```

请进行程序填空：



```python
def heap_sort(arr):
    heap_size = len(arr)

    def goDown(i):
        if i * 2 + 1 >= heap_size:  # a[i]没有儿子
            return
        L, R = i * 2 + 1, i * 2 + 2

        if _______________:   # 【1 分】
            s = L
        else:
            s = R

        if arr[s] > arr[i]:
            _______________ # 【2 分】
            goDown(s)

    def heapify():	# 将列表 a 变成一个堆
        for k in range(len(arr) // 2 - 1, -1, -1): # 【1 分】
            goDown(k)

    heapify()
    for i in range(len(arr) - 1, -1, -1):
        _______________ # 【1 分】
        heap_size -= 1
        _______________   # 【1 分】


a = list(map(int, input().split()))
heap_sort(a)
for x in a:
    print(x, end=" ")

```



卷面写法怪异，正常写法应该是

```python
def heapify(arr, n, i):
    largest = i  # 将当前节点标记为最大值
    left = 2 * i + 1  # 左子节点的索引
    right = 2 * i + 2  # 右子节点的索引

    # 如果左子节点存在且大于根节点，则更新最大值索引
    if left < n and arr[i] < arr[left]:
        largest = left

    # 如果右子节点存在且大于根节点或左子节点，则更新最大值索引
    if right < n and arr[largest] < arr[right]:
        largest = right

    # 如果最大值索引发生了变化，则交换根节点和最大值，并递归地堆化受影响的子树
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)


def buildMaxHeap(arr):
    n = len(arr)

    # 从最后一个非叶子节点开始进行堆化
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)


def heapSort(arr):
    n = len(arr)

    buildMaxHeap(arr)  # 构建大顶堆

    # 逐步取出堆顶元素（最大值），并进行堆化调整
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # 交换堆顶元素和当前最后一个元素
        heapify(arr, i, 0)  # 对剩余的元素进行堆化

    return arr

a = list(map(int, input().split()))
heapSort(a)
for x in a:
    print(x, end=" ")
```

