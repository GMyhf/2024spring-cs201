# 20240514 数算B-12班-笔试（模考）

Updated 1649 GMT+8 May 12, 2024

2024 spring, Complied by Hongfei Yan



说明：

1）2024/5/14 15:00～17:00，笔试，线下理教410教室有x人+线上y人。

2）周二5月14日15:00～17:00，课堂上进行笔试（电脑上完成），考题在canvas平台，届时开放。

题目包括：选择、判断、填空、简答、算法填空；有的题目需要拍照上传。

请大家带笔记本（pad没有试过，估计也可以），草稿纸，cheat paper，个人独立完成。

预计考100分题目，包括：15个选择题30分，10个判断题10分，10个填空题（改造为选择形式）20分，3个简答20分，2个算法20分。期末考试是120分钟，我们利用两节课加课间时间120分钟完成。

不计分。笔试后再上课，可能线下/线上同学顺序来讲解题目，每人一个。讲解时候（最好到讲台），先介绍下自己的姓名、院系，复述一下题面，然后讲解该题目答案。

笔试范围包括：栈、队列、优先队列、排序、散列表、哈夫曼、调度场、各种树的定义、操作（如各种遍历），时间复杂度、图等。



# 一．选择题（30 分，每小题 2 分）

1. 双向链表中的每个结点有两个引用域，prev 和 next，分别引用当前结点的前驱与后继，设 p 引用链表中的一个结点，q 引用一待插入结点，现要求在 p 前插入 q，则正确的插入操作为（   ）。

   A：p.prev=q; q.next=p; p.prev.next=q; q.prev=p.prev;
   B：q.prev=p.prev; p.prev.next=q; q.next=p; p.prev=q.next;
   C：q.next=p; p.next=q; p.prev.next=q; q.next=p;
   D：p.prev.next=q; q.next=p; q.prev=p.prev; p.prev=q.

   

2. 给定一个 N 个相异元素构成的有序数列，设计一个递归算法实现数列的二分查找，考察递归过程中栈的使用情况，请问这样一个递归调用栈的最小容量应为（  ）。
   A：N	B：N/2	C：$\lceil \log_{2}(N) \rceil$	D：$\lceil \log_{2}(N+1) \rceil$​

   

3. 数据结构有三个基本要素:逻辑结构、存储结构以及基于结构定义的行为(运算)。下列概念中(  )属于存储结构。
   A:线性表	B:链表	C:字符串	D:二叉树

   

4. 为了实现一个循环队列（或称环形队列），采用数组 Q[0..m-1]作为存储结构,其中变量 rear 表示这个循环队列中队尾元素的实际位置，添加结点时按 rear=(rear+1) % m 进行指针移动，变量length 表示当前队列中的元素个数，请问这个循环队列的队列首位元素的实际位置是（  ）。
   A：rear-length	B：(1+rear+m-length) % m	C：(rear-length+m) % m	D：m-length

   

5. 给定一个二叉树，若前序遍历序列与中序遍历序列相同，则二叉树是（  ）。
   A：根结点无左子树的二叉树
   B：根结点无右子树的二叉树
   C：只有根结点的二叉树或非叶子结点只有左子树的二叉树
   D：只有根结点的二叉树或非叶子结点只有右子树的二叉树

   

6. 用 Huffman 算法构造一个最优二叉编码树，待编码的字符权值分别为{3，4，5，6，8，9，11，12}，请问该最优二叉编码树的带权外部路径长度为（ B ）。（补充说明：树的带权外部路径长度定义为树中所有叶子结点的带权路径长度之和；其中，结点的带权路径长度定义为该结点到树根之间的路径长度与该结点权值的乘积）（  ）
   A：58	B：169	C：72	D：18

   

7. 假设需要对存储开销 1GB (GigaBytes) 的数据进行排序，但主存储器（RAM）当前可用的存储空间只有 100MB (MegaBytes)。针对这种情况，（  ）排序算法是最适合的。
   A：堆排序	B：归并排序	C：快速排序	D：插入排序

   

8. 已知一个无向图 G 含有 18 条边，其中度数为 4 的顶点个数为 3，度数为 3 的顶点个数为 4，其他顶
   点的度数均小于 3，请问图 G 所含的顶点个数至少是（  ）。
   A: 10    B: 11    C: 13    D: 15

   

9. 给定一个无向图 G，从顶点 V0 出发进行无向图 G 的深度优先遍历，访问的边集合为： {(V0,V1),
   (V0,V4), (V1,V2), (V1,V3), (V4,V5), (V5,V6)}，则下面哪条边（  ）不能出现在 G 中？
   A: (V0, V2)      B: (V4, V6)
   C: (V4, V3)      D: (V0, V6)

   

10. 已知一个有向图 G 的邻接入边表（或称逆邻接表）如下图所示，从顶点 v0 出发对该图 G 进行深度
    优先周游，得到的深度优先周游结点序列为（  ）。
    A： V0V1V4V3V2   B：V0V1V2V3V4    C：V0V1V3V2V4. D：V0V2V1V3V4

    <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240511155818050.png" alt="image-20240511155818050" style="zoom:50%;" />

    

11. 若按照排序的稳定性和不稳定性对排序算法进行分类，则（  ）是不稳定排序。
    A：冒泡排序	B：归并排序	C：直接插入排序	D：希尔排序

    

12. 以下（  ）分组中的两个排序算法的最坏情况下时间复杂度的大 O 表示相同。
    A：快速排序和堆排序 B：归并排序和插入排序 C：快速排序和选择排序 D：堆排序和冒泡排序

    

13. 设结点 X 和 Y 是二叉树中任意的两个结点，在该二叉树的先根周游遍历序列中 X 出现在 Y 之前，而在其后根周游序列中 X 出现在 Y 之后，则 X 和 Y 的关系是（  ）。
    A：X 是 Y 的左兄弟    B：X 是 Y 的右兄弟
    C：X 是 Y 的祖先    D：X 是 Y 的后裔

    

14. 考虑一个森林 F，其中每个结点的子结点个数均不超过 2。如果森林 F 中叶子结点的总个数为 L，度数为 2 结点（子结点个数为 2）的总个数为 N，那么当前森林 F 中树的个数为（  ）。
    A：L-N-1    B：无法确定    C：L-N    D：N-L

    

15. 回溯法是一类广泛使用的算法，以下叙述中不正确的是（  ）。
    A：回溯法可以系统地搜索一个问题的所有解或者任意解
    B：回溯法是一种既具备系统性又具备跳跃性的搜索算法
    C：回溯算法需要借助队列数据结构来保存从根结点到当前扩展结点的路径
    D：回溯算法在生成解空间的任一结点时，先判断当前结点是否可能包含问题的有效解，如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向祖先结点回溯





# 二．判断

（10 分，每小题 1 分；对填写“Y”, 错填写“N” ）

1. （  ）对任意一个连通的、无环的无向图，从图中移除任何一条边得到的图均不连通。

2. （  ）给定一棵二叉树，前序周游序列和中序周游序列分别是 HGEDBFCA 和 EGBDHFAC 时，其后序周游序列必是 EBDGACFH。

3. （  ）假设一棵二叉搜索树的结点数值在 1 到 1000 之间，现在查找数值为 363 的结点。以下三个序列皆有可能是查过的序列：A). 2, 252, 401, 398, 330, 344, 397, 363; B). 925, 202, 911, 240, 912, 245,363; C). 935, 278, 347, 621, 299, 392, 358, 363。

4. （  ）构建一个含 N 个结点的（二叉）最小值堆，建堆的时间复杂度大 O 表示为 $O(Nlog_2N)$。

5. （  ）队列是动态集合，其定义的出队列操作所移除的元素总是在集合中存在时间最长的元素。

6. （  ）任一有向图的拓扑序列既可以通过深度优先搜索求解，也可以通过宽度优先搜索求解。

7. （  ）对任一连通无向图 G，其中 E 是唯一权值最小的边，那么 E 必然属于任何一个最小生成树。

8. （  ）对一个包含负权值边的图，迪杰斯特拉(Dijkstra)算法能够给出最短路径问题的正确答案。

9. （  ）分治算法通常将原问题分解为几个规模较小但类似于原问题的子问题，并要求算法实现写成某种递归形式，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

10. （  ）考察某个具体问题是否适合应用动态规划算法，必须判定它是否具有最优子结构性质。






# 三．填空（20 分，每题 2 分）

1. 目标串长是 n，模式串长是 m，朴素模式匹配算法思想为：从目标串第一个字符开始，依次与模式串字符匹配；若匹配失败，则尝试匹配的目标串起始字符位置往后移一位，重新开始依次和模式串字符匹配；……. ；直到匹配成功或遍历完整个目标串为止。则该算法中字符的最多比较次数是 _ _ _ _ （使用大 O 表示法）。

2. 在一棵含有 n 个结点的树中，只有度（树节点的度指子节点数量）为 k 的分支结点和度为 0 的终端（叶子）结点，则该树中含有的终端（叶子）结点的数目为： _ _ _ _ 。

3. 对一组记录进行非递减排序，其关键码为[46，70，56，38，40，80]，则利用快速排序的方法，以第一个记录为基准得到的第一次划分结果为 _ _ _ _ 

4. 对长度为 3 的顺序表进行查找，若查找第一个元素的概率为 1/2，查找第二个元素的概率为 1/4，查找第三个元素的概率为 1/8，则执行任意查找需要比较元素的平均个数为 _ _ _ _ 。

5. 设有一组记录的关键字为{19，14，23，1，68，20，84，27，55，11，10，79}，用链地址法（拉链法）构造散列表，散列函数为 H(key)=key MOD 13, 散列地址为 1 的链中有 _ _ _ _  个记录。
   
6. 删除长度为 n 的顺序表的第 i 个数据元素需要移动表中的  _ _ _ _ 个数据元素。（1<=i<=n）

7. 已知以数组表示的小根堆为[8，15，10，21，34，16，12]，删除关键字 8 之后需要重新建堆，在此过程中，关键字的比较次数是 _ _ _ _ _ 。

8. 在广度优先遍历、拓扑排序、求最短路径三种算法中，可以判断出一个有向图是否有环（回路）的是 _ _ _ _ 。

9. 有 n（n>=2）个顶点的有向强连通图最少有 _ _ _ _ _ 条边。

10. 若栈 S1 中保存整数，栈 S2 中保存运算符，函数 F() 依次执行下述各步操作：
    ①从 S1 中依次弹出两个操作数 a 和 b (先弹出 a，再弹出 b)；
    ②从 S2 中弹出一个运算符 op;
    ③执行相应的运算 b op a;
    ④将运算结果压入 S1 中。
    假定 S1 中的操作数依次是 5，8，3，2（2 在栈顶），S2 中的运算符依次是*，-，//（//在栈顶）。调用三次 F() 后，S1 栈顶保存的值是 _ _ _ _ 。

    





# 四．简答（3题，共20分）

1. （7 分）试用 Dijkstra 算法求出下图中顶点 1 到其余各顶点的最短路径，写出算法执行过程中各步的状态，填入下表。
   
   
   
   
   
   ```mermaid
   graph LR
       1((1)) --> |30|2((2)); 1--> |10|5((5)); 1 --> |60|4((4))
       2((2)) --> |20|3((3))
       3((3)) --> |15|4((4))
       5((5)) --> |15|2; 5 --> |7|6((6))
       6((6)) --> |3|2; 6 --> |16|3; 6 --> |8|7
       7((7)) --> |6|3; 7 --> |3|4; 7 --> |10|8((8))
       8 --> |6|4
   ```
   





<p align="right">顶点1到其他顶点的最短路径长度</p>

| 所选顶点 | U(已确定最短路径的顶点集合) | T(未确定最短路径的顶点集合) | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| -------- | --------------------------- | --------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 初态     | {1}                         | {2, 3, 4, 5, 6, 7, 8}       | 30   | ∞    | 60   | 10   | ∞    | ∞    | ∞    |
|          |                             |                             |      |      |      |      |      |      |      |
|          |                             |                             |      |      |      |      |      |      |      |
|          |                             |                             |      |      |      |      |      |      |      |
|          |                             |                             |      |      |      |      |      |      |      |
|          |                             |                             |      |      |      |      |      |      |      |
|          |                             |                             |      |      |      |      |      |      |      |
|          |                             |                             |      |      |      |      |      |      |      |



  

2. （6 分）给定一组记录的关键码集合为{18，73，5，10，68，99，27}，回答下列 3 个问题：
   a) 画出按照记录顺序构建形成的二叉排序（搜索）树（2 分）；
   b) 画出删除关键码为 73 后的二叉排序树（2 分）。
   c) 画出令原关键码集合（未删除 73 前）查询效率最高的最优二叉排序树（仅需考虑关键码查询成功时的效率，且集合内每个关键码被查询概率相等）（2 分）。







3. （7 分）奇偶交换排序如下所述：对于原始记录序列 {a1, a2, a3, ……, an}，第一趟对所有奇数 i，将ai 和 ai+1 进行比较，若 ai > ai+1，则将二者交换；第二趟对所有偶数 i；第三趟对所有奇数 i;第四趟对所有偶数 i，…，依次类推直到整个记录序列有序为止。代码如下：
   
   ```python
   def ExSort(a, n):  # a[1..n]为待排序记录，n为记录数目
   
       change1 = change2 = True  # 标志变量, bool型
       if n <= 0:
           return "Error"
       while (change1 or change2):
   
           change1 = False  # 奇数，
           for i in range(1, n, 2):
               if a[i] > a[i+1]:
                  a[i], a[i+1] = a[i+1], a[i]
                  change1 = True
   
           if not change1 and not change2:
               break
   
           change2 = False  # 偶数
           for i in range(2, n, 2):
               if a[i] > a[i+1]:
                   a[i], a[i+1] = a[i+1], a[i]
                   change2 = True
   ```
   
   a) 请写出序列 {18，73，5，10，68，99，27，10} 在前 4 趟排序中每趟排序后的结果。（2 分）
   b) 奇偶交换排序是否是稳定的排序？（1 分）
   c) 在序列为初始状态为“正序”和“逆序”两种情况下，试给出序列长度为 n 的情况下，排序过程所需进行的关键码比较次数和记录的交换次数？（4 分）
   
   
   
   





# 五．算法填空（2题，共20分）

1. 填空完成下列程序：读入一个整数序列，用单链表存储之，然后将该单链表颠倒后输出该单链表内容。算法输入的一行是 n 个整数，即要存入单链表的整数序列。

   样例输入
   1 2 3 4 5
   样例输出
   5 4 3 2 1

   

   ```python
   class Node:
       def __init__(self, data, next = None):
           self.data, self.next = data, next
   
   class LinkedList:
       def __init__(self, lst):
           self.head = Node(lst[0])
           p = self.head
           for i in lst[1:]:
               p.next = _______________   #（1分）
               p = _______________  				#（2分）
   
       def reverse(self): 
           p = self.head.next
           self.head.next = _______________   #（2分）
           while p is not None:
               q = p
               p = _______________  				#（1分）
               q.next = _______________  #（2分）
               _______________    		#（2分）
   
   
       def print_list(self):
           p = self.head
           while p:
               print(p.data, end=" ")
               p = p.next
           print()
   
   a = list(map(int, input().split()))
   a = LinkedList(a)
   a.reverse()
   a.print_list()
   
   ```





2. 填空完成下列程序：输入一棵二叉树的扩充二叉树的先根周游（前序遍历）序列，构建该二叉树，并输出它的中根周游（中序遍历）序列。这里定义一棵扩充二叉树是指将原二叉树中的所有空引用增加一个表示为@的虚拟叶结点。譬如下图所示的一棵二叉树，
   输入样例：
   ABD@G@@@CE@@F@@
   输出样例：
   DGBAECF



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403090101091.png" alt="image-20240309010107665" style="zoom: 50%;" />



```python
s = input()
ptr = 0

class BinaryTree:
    def __init__(self, data, left=None, right=None):
        self.data, self.left, self.right = data, left, right

    def addLeft(self, tree):
        self.left = tree

    def addRight(self, tree):
        self.right = tree

    def inorderTraversal(self):
        if self.left:
            _______________    # (1分) 
        print(self.data, end="")
        if self.right:
            _______________   # (1分) 

def buildTree():
    global ptr
    if s[ptr] == "@":
        ptr += 1
        _______________             # (2分) 
    tree = _______________   # (1分) 
    ptr += 1
    _______________   # (2分) 
    _______________  # (2分) 

    return tree

tree = _______________  # (1分)
tree.inorderTraversal()

```



