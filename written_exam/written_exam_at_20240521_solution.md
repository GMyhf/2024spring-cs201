# 20240514 数算B-12班-笔试（模考）

Updated 0914 GMT+8 May 16, 2024

2024 spring, Complied by Hongfei Yan



说明：



# 一．选择题（30 分，每小题 2 分）

1. 在数据结构中，从逻辑上可以把数据结构分成（ C  ）。

   A．动态结构和静态结构   B．紧凑结构和非紧凑结构

   C．线性结构和非线性结构  D．内部结构和外部结构

   

2. 与数据元素本身的形式、内容、相对位置、个数无关的是数据的（ C ）。

   A．存储结构        B．存储实现

   C．逻辑结构        D．运算实现

   

3. 通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着( B )。

   A．数据具有同一特点

   B．不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致

   C．每个数据元素都一样

   D．数据元素所包含的数据项的个数要相等

   

4. 以下说法正确的是（ D ）。

   A．数据元素是数据的最小单位

   B．数据项是数据的基本单位

   C．数据结构是带有结构的各数据项的集合

   D．一些表面上很不相同的数据可以有相同的逻辑结构

    

5. 以下与数据的存储结构无关的术语是（ C ）。
   A．顺序队列    B. 链表    C. 有序表     D. 链栈

   

## 1.1 线性表

6. 在n个结点的顺序表中，算法的时间复杂度是O(1)的操作是（ A ）

   A．访问第i个结点（1≤i≤n）和求第i个结点的直接前驱（2≤i≤n） 

   B．在第i个结点后插入一个新结点（1≤i≤n）

   C．删除第i个结点（1≤i≤n）

   D．将n个结点从小到大排序

   

   

7. 向一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动 的元素个数为（ B ）。
   A．8   B．63.5    C．63   D．7

   

8. 链接存储的存储结构所占存储空间（ A ）。

   A．分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针

   B．只有一部分，存放结点值

   C．只有一部分，存储表示结点间关系的指针

   D．分两部分，一部分存放结点值，另一部分存放结点所占单元数

   

9. 线性表若采用链式存储结构时，要求内存中可用存储单元的地址（ D ）。

   A．必须是连续的    B．部分地址必须是连续的

   C．一定是不连续的   D．连续或不连续都可以

   

10. 线性表Ｌ在（ B  ）情况下适用于使用链式结构实现。

    A．需经常修改Ｌ中的结点值   Ｂ．需不断对Ｌ进行删除插入 

    C．Ｌ中含有大量的结点     Ｄ．Ｌ中结点结构复杂

    

11. 单链表的存储密度（ C ）。
    A．大于1    B．等于1   C．小于1  D．不能确定

    

12. 将两个各有n个元素的有序表归并成一个有序表，其最少的比较次数是（ A ）。
    A．n       B．2n-1     C．2n     D．n-1

    

13. 在一个长度为n的顺序表中，在第i个元素（1≤i≤n+1）之前插入一个新元素时须向后移动（ B ）个元素。
    A．n-i      B．n-i+1    C．n-i-1    D．i

    

14. 线性表L=(a1，a2,……an)，下列说法正确的是（ D ）。

    A．每个元素都有一个直接前驱和一个直接后继

    B．线性表中至少有一个元素

    C．表中诸元素的排列必须是由小到大或由大到小

    D．除第一个和最后一个元素外，其余每个元素都有一个且仅有一个直接前驱和直接后继。

    

15. 若指定有n个元素的向量，则建立一个有序单链表的时间复杂性的量级是（ C ）。
    A．O(1)      B．O(n)       C．O(n^2)      D．$O(nlog_2n)$

    #建立一个有序单链表的时间复杂度是$O(n^2)$。这是因为在单链表中插入元素需要遍历链表找到正确的位置，而每次插入的时间复杂度是O(n)，如果需要插入n个元素，那么总的时间复杂度就是O(n^2)。

16. 以下说法错误的是（ D ）。

    A．求表长、定位这两种运算在采用顺序存储结构时实现的效率不比采用链式存储结构时实现的效率低

    B．顺序存储的线性表可以随机存取

    C．由于顺序存储要求连续的存储区域，所以在存储管理上不够灵活

    D．线性表的链式存储结构优于顺序存储结构

    

17. 在单链表中，要将s所指结点插入到p所指结点之后，其语句应为（ D ）。

    A. s.next = p.next + 1; p.next = s;

    B. p.next = s; s.next = p.next;

    C. s.next = p.next; p.next = s.next;

    D. s.next = p.next; p.next = s;

18. 在双向链表存储结构中，删除p所指的结点时须修改指针（ A ）。

    A. p.next.prior = p.prior; p.prior.next = p.next;

    B. p.next = p.next.next; p.next.prior = p;

    C. p.prior.next = p; p.prior = p.prior.prior;

    D. p.prior = p.next.next; p.next = p.prior.prior;

19. 在双向循环链表中，在p指针所指的结点后插入q所指向的新结点，其修改指针的操作是（ C ）。

    A. p.next = q; q.prior = p; p.next.prior = q; q.next = q;

    B. p.next = q; p.next.prior = q; q.prior = p; q.next = p.next;

    C. q.prior = p; q.next = p.next; p.next.prior = q; p.next = q;

    D. q.prior = p; q.next = p.next; p.next = q; p.next.prior = q;



## 1.2 栈和队列

（1）若让元素1，2，3，4，5依次进栈，则出栈次序不可能出现在（ C ）种情况。

A．5，4，3，2，1  B．2，1，5，4，3   C．4，3，1，2，5   D．2，3，5，4，1

（2）若已知一个栈的入栈序列是1，2，3，…，n，其输出序列为p1，p2，p3，…，pn，若p1=n，则pi为（  ）。

  A．i        B．n-i        C．n-i+1      D．不确定

（3）数组Ｑ［ｎ］用来表示一个循环队列，ｆ为当前队列头元素的前一位置，ｒ为队尾元素的位置，假定队列中元素的个数小于ｎ，计算队列中元素个数的公式为（  ）。

A．r-f       B．(n+f-r)%n    C．n+r-f      D．（n+r-f)%n

（4）链式栈结点为：(data,link)，top指向栈顶.若想摘除栈顶结点，并将删除结点的值保存到x中,则应执行操作（ ）。

A．x=top->data;top=top->link；    B．top=top->link;x=top->link；  

C．x=top;top=top->link；        D．x=top->link；

（5）设有一个递归算法如下

​    int fact(int n) { //n大于等于0

​       if(n<=0) return 1;

​       else return n*fact(n-1);    }

则计算fact(n)需要调用该函数的次数为（ ）。 

A． n+1       B． n-1        C． n         D． n+2

（6）栈在 （ ）中有所应用。

A．递归调用    B．函数调用   C．表达式求值    D．前三个选项都有

（7）为解决计算机主机与打印机间速度不匹配问题，通常设一个打印数据缓冲区。主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是（ ）。

A．队列      B．栈       C． 线性表      D．有序表

（8）设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5和e6依次进入栈S，一个元素出栈后即进入Q，若6个元素出队的序列是e2、e4、e3、e6、e5和e1，则栈S的容量至少应该是（　）。

A．2        B．3       C．4        D． 6

（9）在一个具有n个单元的顺序栈中，假设以地址高端作为栈底，以top作为栈顶指针，则当作进栈处理时，top的变化为（　）。 

A．top不变    B．top=0      C．top--       D．top++

（10）设计一个判别表达式中左，右括号是否配对出现的算法，采用（　）数据结构最佳。

A．线性表的顺序存储结构       B．队列   

C. 线性表的链式存储结构        D. 栈

（11）用链接方式存储的队列，在进行删除运算时（　）。

A. 仅修改头指针            B. 仅修改尾指针

C. 头、尾指针都要修改        D. 头、尾指针可能都要修改

（12）循环队列存储在数组A[0..m]中，则入队时的操作为（　）。

A. rear=rear+1            B. rear=(rear+1)%(m-1)

 C. rear=(rear+1)%m          D. rear=(rear+1)%(m+1)

（13）最大容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是（　）。

 A. (rear+1)%n == front          B. rear == front                             

C．rear+1 == front           D. (rear-l)%n == front

（14）栈和队列的共同点是（　）。

A. 都是先进先出            B. 都是先进后出  

C. 只允许在端点处插入和删除元素    D. 没有共同点

（15）一个递归算法必须包括（　）。

A. 递归部分              B. 终止条件和递归部分

C. 迭代部分              D. 终止条件和迭代部分





# 二．判断

（10 分，每小题 1 分；对填写“Y”, 错填写“N” ）

1. （ Y ）对任意一个连通的、无环的无向图，从图中移除任何一条边得到的图均不连通。

2. （ Y ）给定一棵二叉树，前序周游序列和中序周游序列分别是 HGEDBFCA 和 EGBDHFAC 时，其后序周游序列必是 EBDGACFH。

3. （ N ）假设一棵二叉搜索树的结点数值在 1 到 1000 之间，现在查找数值为 363 的结点。以下三个序列皆有可能是查过的序列：A). 2, 252, 401, 398, 330, 344, 397, 363; B). 925, 202, 911, 240, 912, 245,363; C). 935, 278, 347, 621, 299, 392, 358, 363。

   #911子树左子节点240的右子节点912，不能比911大

4. （ N ）构建一个含 N 个结点的（二叉）最小值堆，建堆的时间复杂度大 O 表示为 $O(Nlog_2N)$。

5. （ Y ）队列是动态集合，其定义的出队列操作所移除的元素总是在集合中存在时间最长的元素。

6. （ N ）任一有向图的拓扑序列既可以通过深度优先搜索求解，也可以通过宽度优先搜索求解。

   #必须是DAG

7. （ Y ）对任一连通无向图 G，其中 E 是唯一权值最小的边，那么 E 必然属于任何一个最小生成树。

8. （ N ）对一个包含负权值边的图，迪杰斯特拉(Dijkstra)算法能够给出最短路径问题的正确答案。

9. （ N ）分治算法通常将原问题分解为几个规模较小但类似于原问题的子问题，并要求算法实现写成某种递归形式，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

   

   #递归的求解子问题，最后子问题足够小可以直接求解，形式不一定是递归。

   #分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。

10. （ Y ）考察某个具体问题是否适合应用动态规划算法，必须判定它是否具有最优子结构性质。

    #如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么称这个问题拥有**最优子结构(Optimal Substructure)**。最优子结构保证了动态规划中原问题的最优解可以由子问题的最优解推导而来。因此，一个问题必须拥有最优子结构，才能使用动态规划去解决。例如数塔问题中，每一个位置的 dp 值都可以由它的两个子问题推导得到。
    至此，重叠子问题和最优子结构的内容已介绍完毕。需要指出，**一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决**。





# 三．填空（20 分，每题 2 分）

1. 目标串长是 n，模式串长是 m，朴素模式匹配算法思想为：从目标串第一个字符开始，依次与模式串字符匹配；若匹配失败，则尝试匹配的目标串起始字符位置往后移一位，重新开始依次和模式串字符匹配；……. ；直到匹配成功或遍历完整个目标串为止。则该算法中字符的最多比较次数是 _ _ _ _ （使用大 O 表示法）。O(mn)

2. 在一棵含有 n 个结点的树中，只有度（树节点的度指子节点数量）为 k 的分支结点和度为 0 的终端（叶子）结点，则该树中含有的终端（叶子）结点的数目为： _ _ _ _ 。n - (n-1)/k

   #设叶节点x个，分支节点n-x个，树的性质有节点数等于所有节点度数和+1，(n-x)*k + 1 = n, x = n - (n-1)/k

3. 对一组记录进行非递减排序，其关键码为[46，70，56，38，40，80]，则利用快速排序的方法，以第一个记录为基准得到的第一次划分结果为 _ _ _ _ 。

   #[38, 40, 46, 56, 70,80]。基本知识点，由于算法有多种实现，只需要46把数列分开了就行

4. 对长度为 3 的顺序表进行查找，若查找第一个元素的概率为 1/2，查找第二个元素的概率为 1/4，查找第三个元素的概率为 1/8，则执行任意查找需要比较元素的平均个数为 _ _ _ _ 。

   #$1*(1/2) + 2*(1/4) + 3*(1/8) + 3*(1/8) = 1.75$, 还有1/8的失败查询概率。

5. 设有一组记录的关键字为{19，14，23，1，68，20，84，27，55，11，10，79}，用链地址法（拉链法）构造散列表，散列函数为 H(key)=key MOD 13, 散列地址为 1 的链中有 _ _ _ _  个记录。4

6. 删除长度为 n 的顺序表的第 i 个数据元素需要移动表中的  _ _ _ _ 个数据元素，（1<=i<=n）。n - i

7. 已知以数组表示的小根堆为[8，15，10，21，34，16，12]，删除关键字 8 之后需要重新建堆，在此过程中，关键字的比较次数是 _ _ _ _ _ 。3

8. 在广度优先遍历、拓扑排序、求最短路径三种算法中，可以判断出一个有向图是否有环（回路）的是 _ _ _ _ 。拓扑排序

   #求最短路径和广度优先遍历中，发现重复访问的节点时，并不知道该节点是否当前节点的祖先拓扑排序有一种实现是用入度来判断，输出入度为0的节点。

9. 有 n（n>=2）个顶点的有向强连通图最少有 _ _ _ _ _ 条边。n

10. 若栈 S1 中保存整数，栈 S2 中保存运算符，函数 F() 依次执行下述各步操作：
    ①从 S1 中依次弹出两个操作数 a 和 b (先弹出 a，再弹出 b)；
    ②从 S2 中弹出一个运算符 op;
    ③执行相应的运算 b op a;
    ④将运算结果压入 S1 中。
    假定 S1 中的操作数依次是 5，8，3，2（2 在栈顶），S2 中的运算符依次是*，-，//（//在栈顶）。调用三次 F() 后，S1 栈顶保存的值是 _ _ _ _ 。35

    





# 四．简答（3题，共20分）

1. （7 分）试用 Dijkstra 算法求出下图中顶点 1 到其余各顶点的最短路径，写出算法执行过程中各步的状态，填入下表。
   
   
   
   
   
   ```mermaid
   graph LR
       1((1)) --> |30|2((2)); 1--> |10|5((5)); 1 --> |60|4((4))
       2((2)) --> |20|3((3))
       3((3)) --> |15|4((4))
       5((5)) --> |15|2; 5 --> |7|6((6))
       6((6)) --> |3|2; 6 --> |16|3; 6 --> |8|7
       7((7)) --> |6|3; 7 --> |3|4; 7 --> |10|8((8))
       8 --> |6|4
   ```
   





<p align="right">顶点1到其他顶点的最短路径长度</p>

| 所选顶点 | U(已确定最短路径的顶点集合) | T(未确定最短路径的顶点集合) | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| -------- | --------------------------- | --------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 初态     | {1}                         | {2, 3, 4, 5, 6, 7, 8}       | 30   | ∞    | 60   | 10   | ∞    | ∞    | ∞    |
| 第1步    | {1, 5}                      | {2, 3, 4, 6, 7, 8}          | 25   | ∞    | 60   | -    | 17   | ∞    | ∞    |
| 第2步    | {1, 5, 6}                   | {2, 3, 4, 7, 8}             | 20   | 33   | 60   | -    | -    | 25   | ∞    |
| 第3步    | {1, 5, 6, 2}                | {3, 4, 7, 8}                | -    | 33   | 60   | -    | -    | 25   | ∞    |
| 第4步    | {1, 5, 6, 2, 7}             | {3, 4, 8}                   | -    | 31   | 28   | -    | -    | -    | 35   |
| 第5步    | {1, 5, 6, 7, 2, 4}          | {3, 8}                      | -    | 31   | -    | -    | -    | -    | 36   |
| 第6步    | {1, 5, 6, 7, 2, 4, 3}       | {8}                         | -    | -    | -    | -    | -    | -    | 36   |
|          |                             |                             |      |      |      |      |      |      |      |



  

2. （6 分）给定一组记录的关键码集合为{18，73，5，10，68，99，27}，回答下列 3 个问题：
   a) 画出按照记录顺序构建形成的二叉排序（搜索）树（2 分）；
   b) 画出删除关键码为 73 后的二叉排序树（2 分）。
   c) 画出令原关键码集合（未删除 73 前）查询效率最高的最优二叉排序树（仅需考虑关键码查询成功时的效率，且集合内每个关键码被查询概率相等）（2 分）。



#二叉排序树是一种特殊的二叉树，它具有以下性质：

1. 对于树中的每个节点，其左子树中的所有节点的关键码值小于该节点的关键码值。
2. 对于树中的每个节点，其右子树中的所有节点的关键码值大于该节点的关键码值。
3. 左右子树也是二叉排序树。

在构建二叉排序树时，我们按照以下原理：

- 从根节点开始，依次遍历关键码集合中的每个关键码。
- 对于每个关键码，如果树为空，则将关键码作为树的根节点。如果树不为空，则按照二叉排序树的性质，找到适当的位置插入关键码，以保持二叉排序树的性质不变。

具体来说，在插入关键码时，我们从根节点开始，逐级比较关键码值，并根据比较结果决定向左子树或右子树移动，直到找到合适的插入位置。如果待插入的关键码已经存在于树中，则不执行任何操作（可以视为树中已经存在该关键码）。

这样，通过按照关键码集合中记录的顺序依次插入节点，就可以构建出一个二叉排序树。



让我们逐个回答这些问题：

a) 二叉排序树构建过程如下：

```
           18
          /  \
        5     73
         \    / \
         10  68 99
              /
            27
```



b) 删除关键码为 73 后的二叉排序树：

```
           18
          /  \
        5     68
         \    / \
         10  27 99
```

c) 查询效率最高的最优二叉排序树：

由于关键码集合内每个关键码被查询概率相等，最优二叉排序树应该是平衡树，即左右子树高度差不超过1。因此，我们可以构建一个高度平衡的二叉排序树。

```
           27
          /  \
        10    73
       /  \   / \
      5   18 68 99
```

这是一棵高度平衡的二叉排序树，查询效率最高，因为平衡树的查找时间复杂度是 O(log n)。



3. （7 分）奇偶交换排序如下所述：对于原始记录序列 {a1, a2, a3, ……, an}，第一趟对所有奇数 i，将ai 和 ai+1 进行比较，若 ai > ai+1，则将二者交换；第二趟对所有偶数 i；第三趟对所有奇数 i;第四趟对所有偶数 i，…，依次类推直到整个记录序列有序为止。代码如下：
   
   ```python
   def ExSort(a, n):  # a[1..n]为待排序记录，n为记录数目
   
       change1 = change2 = True  # 标志变量, bool型
       if n <= 0:
           return "Error"
       while (change1 or change2):
   
           change1 = False  # 奇数，
           for i in range(1, n, 2):
               if a[i] > a[i+1]:
                  a[i], a[i+1] = a[i+1], a[i]
                  change1 = True
   
           if not change1 and not change2:
               break
   
           change2 = False  # 偶数
           for i in range(2, n, 2):
               if a[i] > a[i+1]:
                   a[i], a[i+1] = a[i+1], a[i]
                   change2 = True
   ```
   
   a) 请写出序列 {18，73，5，10，68，99，27，10} 在前 4 趟排序中每趟排序后的结果。（2 分）
   b) 奇偶交换排序是否是稳定的排序？（1 分）
   c) 在序列为初始状态为“正序”和“逆序”两种情况下，试给出序列长度为 n 的情况下，排序过程所需进行的关键码比较次数和记录的交换次数？（4 分）
   
   
   
   #
   
   a) 序列 {18, 73, 5, 10, 68, 99, 27, 10} 在前4趟排序中每趟排序后的结果如下：
   
   ```python
   def ExSort(a, n):  # a[1..n]为待排序记录，n为记录数目
       change1 = change2 = True  # 标志变量, bool型
       if n <= 0:
           return "Error"
       cnt = 0
       while (change1 or change2):
           change1 = False  # 奇数，
           for i in range(1, n, 2):
               if a[i] > a[i+1]:
                  a[i], a[i+1] = a[i+1], a[i]
                  change1 = True
   
           cnt += 1; print(f"pass {cnt}: {a[1:]}")
           if not change1 and not change2:
               break
   
           change2 = False  # 偶数
           for i in range(2, n, 2):
               if a[i] > a[i+1]:
                   a[i], a[i+1] = a[i+1], a[i]
                   change2 = True
   
           cnt += 1; print(f"pass {cnt}: {a[1:]}")
           if cnt == 4:
               break
   
   # 题面是奇数第一趟，偶数是第二趟，这也没有都都比较，才一半，怎么算一趟？题面有问题吧
   a = [0] + [18, 73, 5, 10, 68, 99, 27, 10]
   ExSort(a, len(a)-1)
   """
   pass 1: [18, 73, 5, 10, 68, 99, 10, 27]
   pass 2: [18, 5, 73, 10, 68, 10, 99, 27]
   pass 3: [5, 18, 10, 73, 10, 68, 27, 99]
   pass 4: [5, 10, 18, 10, 73, 27, 68, 99]
   """
   ```
   
   
   
   b) 奇偶交换排序是稳定的排序。稳定排序是指如果两个元素相等，在排序后它们的相对顺序仍然保持不变。奇偶交换排序在交换过程中只涉及相邻的两个元素，因此相等元素之间的相对顺序不会改变。
   
   c) 在初始状态为“正序”和“逆序”两种情况下，奇偶交换排序的关键码比较次数和记录交换次数如下：
   
   - 正序情况下：
     关键码比较次数：每趟排序将比较 ![$n/2 $](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAtJREFUGFdjYAACAAAFAAGq1chRAAAAAElFTkSuQmCC)*n*/2 
     记录交换次数：0。由于序列已经有序，不需要进行交换，
   
   - 逆序情况下：
     关键码比较次数：每趟排序将比较 ![$n/2 $](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAtJREFUGFdjYAACAAAFAAGq1chRAAAAAElFTkSuQmCC)*n*/2 
     记录交换次数：n/2
   
   





# 五．算法填空（2题，共20分）

1. 填空完成下列程序：读入一个整数序列，用单链表存储之，然后将该单链表颠倒后输出该单链表内容。算法输入的一行是 n 个整数，即要存入单链表的整数序列。

   样例输入
   1 2 3 4 5
   样例输出
   5 4 3 2 1

   ![image-20240229230534964](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240229230534964.png)

   

   ```python
   class Node:
       def __init__(self, data, next = None):
           self.data, self.next = data, next
   
   class LinkedList:
       def __init__(self, lst):
           self.head = Node(lst[0])
           p = self.head
           for i in lst[1:]:
               p.next = Node(i)    # 等号右侧填空（1分）
               p = p.next  				# 等号右侧填空（2分）
   
       def reverse(self): # 把head当pre用，天才 said by 胡睿诚
           p = self.head.next
           self.head.next = None   # 等号右侧填空（2分）
           while p is not None:
               q = p
               p = p.next  				# 等号右侧填空（1分）
               q.next = self.head  # 等号右侧填空（2分）
               self.head = q    		# 留空行，此行代码需要填写（2分）
   
       def reverse_3p(self): # 常规思维：三个指针来反转链表的指针指向关系
           prev = None
           current = self.head
           while current:
               next_node = current.next
               current.next = prev
               prev = current
               current = next_node
           self.head = prev
   
       def print_list(self):
           p = self.head
           while p:
               print(p.data, end=" ")
               p = p.next
           print()
   
   #a = list(map(int, input().split()))
   a = [1, 2, 3, 4, 5]
   b = a.copy()
   a = LinkedList(a)
   b = LinkedList(b)
   a.reverse()
   b.reverse_3p()
   a.print_list()
   b.print_list()
   """
   5 4 3 2 1 
   5 4 3 2 1 
   """
   
   """
   5 4 3 2 1 
   """
   ```




`reverse_3p`这段代码是用来反转一个链表的指针指向关系的。下面是对代码的逐行解释：

1. `prev = None`: 初始化一个变量`prev`，用于保存当前节点的前一个节点，初始值为`None`。

2. `current = self.head`: 初始化一个变量`current`，指向链表的头节点。

3. `while current:`: 进入一个循环，只要`current`不为空（即还有节点未遍历）就继续执行。

4. `next_node = current.next`: 将`current`节点的下一个节点保存到`next_node`中，以备后续使用。

5. `current.next = prev`: 将`current`节点的指针指向前一个节点`prev`，实现了反转指针的方向。

6. `prev = current`: 将`prev`更新为当前节点`current`，为下一轮循环做准备。

7. `current = next_node`: 将`current`更新为下一个节点`next_node`，继续遍历链表。

8. `self.head = prev`: 最后将链表的头节点更新为反转后的链表的头节点`prev`，完成整个链表的反转。

这段代码使用了三个指针：`prev`、`current`、`next_node`，通过不断更新它们的指向关系，实现了链表的反转。



2. 填空完成下列程序：输入一棵二叉树的扩充二叉树的先根周游（前序遍历）序列，构建该二叉树，并输出它的中根周游（中序遍历）序列。这里定义一棵扩充二叉树是指将原二叉树中的所有空引用增加一个表示为@的虚拟叶结点。譬如下图所示的一棵二叉树，
   输入样例：
   ABD@G@@@CE@@F@@
   输出样例：
   DGBAECF



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403090101091.png" alt="image-20240309010107665" style="zoom: 50%;" />



```python
s = input()
ptr = 0

class BinaryTree:
    def __init__(self, data, left=None, right=None):
        self.data, self.left, self.right = data, left, right

    def addLeft(self, tree):
        self.left = tree

    def addRight(self, tree):
        self.right = tree

    def inorderTraversal(self):
        if self.left:
            self.left.inorderTraversal()    # (1分) 
        print(self.data, end="")
        if self.right:
            self.right.inorderTraversal()   # (1分) 

def buildTree():
    global ptr
    if s[ptr] == "@":
        ptr += 1
        return None             # (2分) 
    tree = BinaryTree(s[ptr])   # (1分) 
    ptr += 1
    tree.addLeft(buildTree())   # (2分) 
    tree.addRight(buildTree())  # (2分) 

    return tree

tree = buildTree()
tree.inorderTraversal()

"""
sample input:
ABD@G@@@CE@@F@@

sample output:
DGBAECF
"""
```



笔试中，对于程序阅读理解，要求还是挺高的。因为AC的代码通常有多种写法，如果考出来写的不规范代码，就有点难受。例如：上面程序，递归程序带着全局变量，难受。

较好的写法是：

```python
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def buildTree(preorder):
    if not preorder:
        return None

    data = preorder.pop(0)
    if data == "@":
        return None

    node = TreeNode(data)
    node.left = buildTree(preorder)
    node.right = buildTree(preorder)

    return node

def inorderTraversal(node):
    if node is None:
        return []

    result = []
    result.extend(inorderTraversal(node.left))
    result.append(node.data)
    result.extend(inorderTraversal(node.right))

    return result

preorder = input()
tree = buildTree(list(preorder))

inorder = inorderTraversal(tree)
print(''.join(inorder))

"""
sample input:
ABD@G@@@CE@@F@@

sample output:
DGBAECF
"""
```

